---
phase: 09-backend-service-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/profile-service/src/index.ts
  - backend/chat-service/src/index.ts
autonomous: true
requirements:
  - RESIL-05
  - RESIL-06
  - RESIL-07

must_haves:
  truths:
    - "Profile-service stops accepting new HTTP requests on SIGTERM before closing resources"
    - "Profile-service calls pool.end() during shutdown to drain database connections"
    - "Profile-service signal handlers are inside the NODE_ENV !== 'test' block (not at module scope)"
    - "Profile-service has a 10-second force-exit timeout with .unref()"
    - "Profile-service captures app.listen() return value as const server for server.close()"
    - "Chat-service calls pool.end() during shutdown to drain database connections"
    - "Chat-service uses io.close() instead of httpServer.close() (io.close also closes the underlying HTTP server)"
    - "Chat-service calls closeAfterHoursRedisSubscriber() during shutdown"
    - "Chat-service has a guard flag preventing double invocation of pool.end()"
    - "Chat-service force-exit timer uses .unref()"
    - "Sending SIGTERM twice does not crash either service"
    - "All existing tests pass for both services"
  artifacts:
    - path: "backend/profile-service/src/index.ts"
      provides: "gracefulShutdown with guard, server.close, scheduler cleanup, pool.end, 10s timeout"
      contains: "gracefulShutdown"
    - path: "backend/profile-service/src/index.ts"
      provides: "http.Server reference captured from app.listen()"
      contains: "const server = app.listen"
    - path: "backend/chat-service/src/index.ts"
      provides: "Enhanced gracefulShutdown with guard, io.close, Redis cleanup, pool.end"
      contains: "isShuttingDown"
    - path: "backend/chat-service/src/index.ts"
      provides: "closeAfterHoursRedisSubscriber import and call in shutdown"
      contains: "closeAfterHoursRedisSubscriber"
  key_links:
    - from: "backend/profile-service/src/index.ts"
      to: "pool.end()"
      via: "gracefulShutdown calls pool.end() after scheduler cleanup"
      pattern: "await pool\\.end\\(\\)"
    - from: "backend/profile-service/src/index.ts"
      to: "server.close()"
      via: "gracefulShutdown calls server.close() to stop accepting requests"
      pattern: "server\\.close\\("
    - from: "backend/chat-service/src/index.ts"
      to: "pool.end()"
      via: "gracefulShutdown calls pool.end() after io.close"
      pattern: "await pool\\.end\\(\\)"
    - from: "backend/chat-service/src/index.ts"
      to: "io.close()"
      via: "gracefulShutdown uses io.close() instead of httpServer.close()"
      pattern: "io\\.close\\("
    - from: "backend/chat-service/src/index.ts"
      to: "closeAfterHoursRedisSubscriber"
      via: "import from socket/after-hours-handler and call during shutdown"
      pattern: "closeAfterHoursRedisSubscriber"
---

<objective>
Enhance graceful shutdown in profile-service and chat-service to close database pools and all resources cleanly.

Purpose: Profile-service has shutdown handlers at module scope that close schedulers but miss server.close(), pool.end(), guard flag, and force-exit timeout. Chat-service has a partial shutdown handler with httpServer.close() and a timeout, but misses pool.end(), io.close(), Redis subscriber cleanup, guard flag, and .unref() on the timer. Both services risk orphaning database connections and hanging during Railway deployments.

Output: Updated `profile-service/src/index.ts` with consolidated shutdown inside the server block, and updated `chat-service/src/index.ts` with complete resource cleanup.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-backend-service-integration/09-RESEARCH.md

@backend/profile-service/src/index.ts
@backend/chat-service/src/index.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

Profile-service pool (line 244):
```typescript
const pool = createPool({ logger });
```

Profile-service existing shutdown handlers (lines 1784-1799, AT MODULE SCOPE -- must be moved):
```typescript
// Graceful shutdown handlers
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  await closeMatchingScheduler();
  await closeSessionScheduler();
  await closeSessionCleanupJob();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');
  await closeMatchingScheduler();
  await closeSessionScheduler();
  await closeSessionCleanupJob();
  process.exit(0);
});
```

Profile-service server block (lines 1801-1842, app.listen NOT captured):
```typescript
if (process.env.NODE_ENV !== 'test') {
  initializeUploadDirectory()
    .then(async () => {
      // ... scheduler initialization ...
      app.listen(PORT, () => {
        logger.info(`Profile service started`, { port: PORT, environment: process.env.NODE_ENV || 'development' });
      });
    })
    .catch((error) => {
      logger.error('Failed to initialize upload directory', { error });
      process.exit(1);
    });
}
```

Profile-service scheduler close imports (lines 92-99):
```typescript
import { initializeSessionWorker, closeSessionScheduler } from './services/session-scheduler';
import {
  closeMatchingScheduler,
  // ...
} from './services/matching-scheduler';
import {
  closeSessionCleanupJob,
  // ...
} from './services/session-cleanup-job';
```

Chat-service pool (line 218):
```typescript
const pool = createPool({ logger });
```

Chat-service existing shutdown (lines 1628-1666):
```typescript
if (process.env.NODE_ENV !== 'test') {
  httpServer.listen(PORT, () => { ... });
  initializeMessageCleanupJob(pool).catch(...);

  const gracefulShutdown = async (signal: string) => {
    logger.info(`Received ${signal}, starting graceful shutdown...`);
    await closeMessageCleanupJob().catch(...);
    httpServer.close(() => {
      logger.info('HTTP server closed');
      process.exit(0);
    });
    setTimeout(() => {
      logger.warn('Forcefully shutting down after timeout');
      process.exit(1);
    }, 10000);
  };

  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
  process.on('SIGINT', () => gracefulShutdown('SIGINT'));
}
```

Chat-service io variable (line 1622):
```typescript
const io = initializeSocketIO(httpServer, pool);
```

Chat-service closeAfterHoursRedisSubscriber (NOT imported yet, available from):
```typescript
// backend/chat-service/src/socket/after-hours-handler.ts:702
export async function closeAfterHoursRedisSubscriber(): Promise<void> { ... }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate profile-service shutdown with server.close and pool.end</name>
  <files>backend/profile-service/src/index.ts</files>
  <action>
Profile-service needs two changes: (1) DELETE the module-scope signal handlers, (2) ADD consolidated shutdown inside the server startup block with server.close(), pool.end(), guard flag, and 10s force-exit.

**Step 1: DELETE the module-scope shutdown handlers (lines 1784-1799).**

Remove this entire block:
```typescript
// Graceful shutdown handlers
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  await closeMatchingScheduler();
  await closeSessionScheduler();
  await closeSessionCleanupJob();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');
  await closeMatchingScheduler();
  await closeSessionScheduler();
  await closeSessionCleanupJob();
  process.exit(0);
});
```

These must be removed because: (a) they fire during tests since they're at module scope, (b) they duplicate code, (c) they lack server.close, pool.end, guard, and timeout.

**Step 2: Modify the server startup block to capture server reference and add shutdown.**

Replace the `app.listen(...)` line inside the `.then()` callback with:

```typescript
      const server = app.listen(PORT, () => {
        logger.info('Profile service started', { port: PORT, environment: process.env.NODE_ENV || 'development' });
      });

      let isShuttingDown = false;

      const gracefulShutdown = async (signal: string) => {
        if (isShuttingDown) {
          logger.warn(`Duplicate ${signal} received, shutdown already in progress`);
          return;
        }
        isShuttingDown = true;
        logger.info(`Received ${signal}, starting graceful shutdown...`);

        // Force exit after 10 seconds to prevent hung deployments
        const forceExitTimer = setTimeout(() => {
          logger.error('Graceful shutdown timed out after 10s, forcing exit');
          process.exit(1);
        }, 10000);
        forceExitTimer.unref();

        // Stop accepting new HTTP requests
        server.close(() => {
          logger.info('HTTP server closed');
        });

        // Close background schedulers
        await closeMatchingScheduler().catch((err: any) => {
          logger.error('Error closing matching scheduler', { error: err.message });
        });
        await closeSessionScheduler().catch((err: any) => {
          logger.error('Error closing session scheduler', { error: err.message });
        });
        await closeSessionCleanupJob().catch((err: any) => {
          logger.error('Error closing session cleanup job', { error: err.message });
        });

        // Close database pool (drains active clients)
        try {
          await pool.end();
          logger.info('Database pool closed');
        } catch (err) {
          logger.error('Error closing database pool', { error: (err as Error).message });
        }

        process.exit(0);
      };

      process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
      process.on('SIGINT', () => gracefulShutdown('SIGINT'));
```

**Key points:**
1. The `const server = app.listen(...)` captures the http.Server reference -- currently discarded at line 1834.
2. `isShuttingDown` guard prevents double `pool.end()` which throws in pg-pool.
3. Each scheduler close is wrapped in `.catch()` so a Redis failure doesn't prevent pool.end() from running.
4. Shutdown order: server.close (stop HTTP) -> schedulers (background jobs) -> pool.end (DB) -> exit. Pool goes last because scheduler cleanup might need DB.
5. `forceExitTimer.unref()` prevents the timer from keeping the process alive.
6. Signal handlers are now INSIDE the `if (NODE_ENV !== 'test')` block, fixing the test interference issue.

**Step 3: Verify TypeScript compiles:**
```bash
cd backend/profile-service && npx tsc --noEmit
```
  </action>
  <verify>
    <automated>cd "C:/Users/dasbl/AndroidStudioProjects/VLVT/backend/profile-service" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>Profile-service compiles. Module-scope signal handlers are removed. Consolidated gracefulShutdown inside server block includes guard flag, server.close, scheduler cleanup with .catch(), pool.end, 10s force-exit with .unref(), and SIGTERM/SIGINT registration.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance chat-service shutdown with guard, io.close, pool.end, and Redis cleanup</name>
  <files>backend/chat-service/src/index.ts</files>
  <action>
Chat-service needs: (1) add `closeAfterHoursRedisSubscriber` import, (2) replace the existing `gracefulShutdown` function with an enhanced version.

**Step 1: Add the closeAfterHoursRedisSubscriber import.**

Find the existing import from `./socket/after-hours-handler` or add a new import near the other socket imports. The function is exported from `backend/chat-service/src/socket/after-hours-handler.ts` at line 702.

```typescript
import { closeAfterHoursRedisSubscriber } from './socket/after-hours-handler';
```

If there's already an import from `'./socket/after-hours-handler'`, add `closeAfterHoursRedisSubscriber` to it.

**Step 2: Replace the existing gracefulShutdown function (lines 1642-1662).**

Replace this:
```typescript
  // Graceful shutdown handlers
  const gracefulShutdown = async (signal: string) => {
    logger.info(`Received ${signal}, starting graceful shutdown...`);

    // Close message cleanup job
    await closeMessageCleanupJob().catch((err) => {
      logger.error('Error closing message cleanup job', { error: err.message });
    });

    // Close HTTP server
    httpServer.close(() => {
      logger.info('HTTP server closed');
      process.exit(0);
    });

    // Force close after 10 seconds
    setTimeout(() => {
      logger.warn('Forcefully shutting down after timeout');
      process.exit(1);
    }, 10000);
  };
```

With this:
```typescript
  // Graceful shutdown handlers
  let isShuttingDown = false;

  const gracefulShutdown = async (signal: string) => {
    if (isShuttingDown) {
      logger.warn(`Duplicate ${signal} received, shutdown already in progress`);
      return;
    }
    isShuttingDown = true;
    logger.info(`Received ${signal}, starting graceful shutdown...`);

    // Force exit after 10 seconds to prevent hung deployments
    const forceExitTimer = setTimeout(() => {
      logger.error('Graceful shutdown timed out after 10s, forcing exit');
      process.exit(1);
    }, 10000);
    forceExitTimer.unref();

    // Close message cleanup job
    await closeMessageCleanupJob().catch((err) => {
      logger.error('Error closing message cleanup job', { error: err.message });
    });

    // Close Redis subscriber for After Hours events
    await closeAfterHoursRedisSubscriber().catch((err) => {
      logger.error('Error closing After Hours Redis subscriber', { error: err.message });
    });

    // Close Socket.IO (disconnects all clients AND closes underlying HTTP server)
    io.close(() => {
      logger.info('Socket.IO server closed');
    });

    // Close database pool (drains active clients)
    try {
      await pool.end();
      logger.info('Database pool closed');
    } catch (err) {
      logger.error('Error closing database pool', { error: (err as Error).message });
    }

    process.exit(0);
  };
```

**Key changes from the existing code:**
1. **Added guard flag** (`isShuttingDown`): Prevents `pool.end()` from being called twice, which throws `'Called end on pool more than once'`.
2. **Replaced `httpServer.close()` with `io.close()`**: `io.close()` disconnects all Socket.IO clients AND closes the underlying HTTP server in one call. Using both `io.close()` and `httpServer.close()` would cause "Server is not running" errors.
3. **Added `pool.end()`**: Currently missing -- database connections are orphaned on shutdown.
4. **Added `closeAfterHoursRedisSubscriber()`**: The function exists but was never called during shutdown, potentially leaving a Redis subscriber connection alive.
5. **Added `.unref()` to force-exit timer**: The existing timer (line 1658) does NOT have `.unref()`, which means the timer itself keeps the event loop alive. With `.unref()`, if everything shuts down before 10s, the process exits naturally.
6. **Moved `process.exit(0)` out of `httpServer.close()` callback**: Previously, clean exit only happened if `httpServer.close()` callback fired. Now exit happens after pool.end(), regardless of server close callback timing. The force-exit timer is the safety net.

**Step 3: Verify TypeScript compiles:**
```bash
cd backend/chat-service && npx tsc --noEmit
```
  </action>
  <verify>
    <automated>cd "C:/Users/dasbl/AndroidStudioProjects/VLVT/backend/chat-service" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>Chat-service compiles. gracefulShutdown has guard flag, uses io.close() instead of httpServer.close(), calls closeAfterHoursRedisSubscriber(), calls pool.end(), and force-exit timer has .unref().</done>
</task>

<task type="auto">
  <name>Task 3: Verify all service tests pass</name>
  <files>backend/profile-service/src/index.ts, backend/chat-service/src/index.ts</files>
  <action>
Run both service test suites to verify the shutdown changes don't break existing tests.

**Step 1: Run profile-service tests:**
```bash
cd backend/profile-service && npm test 2>&1 | tail -20
```

**Step 2: Run chat-service tests:**
```bash
cd backend/chat-service && npm test 2>&1 | tail -20
```

**Expected:** All tests pass for both services.

**If profile-service tests fail:**
- If signal handler fires during tests: confirm the module-scope handlers (lines 1784-1799) were fully deleted and new handlers are inside `if (NODE_ENV !== 'test')` block.
- If `pool.end is not a function`: check mock setup in test files.

**If chat-service tests fail:**
- If `closeAfterHoursRedisSubscriber is not a function`: check the import path matches exactly `./socket/after-hours-handler`.
- If `io.close is not a function`: verify the `io` variable is imported correctly in tests (it's exported from index.ts line 1670).

**Step 3: Run grep verification for both services:**
```bash
# Profile-service checks
grep -n "gracefulShutdown" backend/profile-service/src/index.ts
grep -n "isShuttingDown" backend/profile-service/src/index.ts
grep -n "pool.end()" backend/profile-service/src/index.ts
grep -n "server.close" backend/profile-service/src/index.ts
grep -n ".unref()" backend/profile-service/src/index.ts

# Chat-service checks
grep -n "isShuttingDown" backend/chat-service/src/index.ts
grep -n "io.close" backend/chat-service/src/index.ts
grep -n "pool.end()" backend/chat-service/src/index.ts
grep -n "closeAfterHoursRedisSubscriber" backend/chat-service/src/index.ts
grep -n ".unref()" backend/chat-service/src/index.ts

# Verify no module-scope signal handlers remain in profile-service
# (should only appear inside the NODE_ENV block, not at module scope)
grep -n "process.on('SIGTERM'" backend/profile-service/src/index.ts
```
  </action>
  <verify>
    <automated>cd "C:/Users/dasbl/AndroidStudioProjects/VLVT" && echo "=== profile-service ===" && cd backend/profile-service && npm test 2>&1 | tail -5 && cd ../.. && echo "=== chat-service ===" && cd backend/chat-service && npm test 2>&1 | tail -5</automated>
  </verify>
  <done>All profile-service and chat-service tests pass. Grep checks confirm: both services have gracefulShutdown with guard flag, pool.end(), force-exit with .unref(). Profile-service has server.close(). Chat-service has io.close() and closeAfterHoursRedisSubscriber(). No module-scope signal handlers remain in profile-service.</done>
</task>

</tasks>

<verification>
1. Profile-service: `grep -n "gracefulShutdown\|isShuttingDown\|pool.end\|server.close\|\.unref" backend/profile-service/src/index.ts` -- all present
2. Chat-service: `grep -n "isShuttingDown\|io.close\|pool.end\|closeAfterHoursRedisSubscriber\|\.unref" backend/chat-service/src/index.ts` -- all present
3. Profile-service module-scope handlers removed: `grep -c "process.on" backend/profile-service/src/index.ts` should show 2 (inside server block only, not 4 from duplicated module-scope)
4. Chat-service uses io.close not httpServer.close in shutdown: `grep "httpServer.close" backend/chat-service/src/index.ts` should return nothing in shutdown context
5. Both services compile: `npx tsc --noEmit` succeeds for both
6. Both service test suites pass: `npm test` succeeds for both
</verification>

<success_criteria>
- Profile-service module-scope signal handlers are deleted
- Profile-service has consolidated gracefulShutdown inside NODE_ENV block with guard, server.close, scheduler cleanup with .catch(), pool.end, 10s force-exit with .unref()
- Chat-service has guard flag (isShuttingDown) preventing double pool.end()
- Chat-service uses io.close() instead of httpServer.close() in shutdown
- Chat-service calls closeAfterHoursRedisSubscriber() during shutdown
- Chat-service calls pool.end() during shutdown
- Chat-service force-exit timer has .unref()
- All existing tests pass for both services
</success_criteria>

<output>
After completion, create `.planning/phases/09-backend-service-integration/09-02-SUMMARY.md`
</output>
