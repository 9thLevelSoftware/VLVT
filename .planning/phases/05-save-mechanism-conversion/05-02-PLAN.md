---
phase: 05-save-mechanism-conversion
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/lib/services/socket_service.dart
  - frontend/lib/services/after_hours_chat_service.dart
  - frontend/lib/widgets/save_match_button.dart
autonomous: true

must_haves:
  truths:
    - "User sees save button in After Hours chat"
    - "User can tap save button to vote to save match"
    - "UI updates when partner saves (shows urgency)"
    - "UI shows success state when both users save"
    - "Save button is disabled while saving or after mutual save"
  artifacts:
    - path: "frontend/lib/services/socket_service.dart"
      provides: "Socket streams for partner_saved and match_saved events"
      contains: "after_hours:partner_saved|after_hours:match_saved"
    - path: "frontend/lib/services/after_hours_chat_service.dart"
      provides: "saveMatch method calling backend endpoint"
      exports: ["saveMatch", "SaveResult"]
    - path: "frontend/lib/widgets/save_match_button.dart"
      provides: "SaveMatchButton widget with state machine"
      exports: ["SaveMatchButton", "SaveButtonState"]
  key_links:
    - from: "socket_service.dart"
      to: "after_hours:partner_saved event"
      via: "StreamController"
      pattern: "_partnerSavedController"
    - from: "after_hours_chat_service.dart"
      to: "/api/after-hours/matches/{matchId}/save"
      via: "http.post"
      pattern: "http.post.*save"
    - from: "save_match_button.dart"
      to: "SaveButtonState enum"
      via: "switch statement"
      pattern: "SaveButtonState"
---

<objective>
Implement Flutter frontend for save functionality with real-time UI updates.

Purpose: Provide users with a clear, responsive save button that shows the current save state and responds to partner actions in real-time.

Output:
- Extended socket_service.dart with partner_saved and match_saved streams
- Extended after_hours_chat_service.dart with saveMatch method
- New save_match_button.dart widget with state machine (notSaved, saving, waitingForPartner, partnerSavedFirst, mutualSaved)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-save-mechanism-conversion/05-RESEARCH.md
@.planning/phases/05-save-mechanism-conversion/05-01-SUMMARY.md

# Existing code to extend
@frontend/lib/services/socket_service.dart
@frontend/lib/services/after_hours_chat_service.dart
@frontend/lib/config/app_config.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Socket Service Save Event Streams</name>
  <files>frontend/lib/services/socket_service.dart</files>
  <action>
Extend socket_service.dart to handle save-related Socket.IO events.

Add two new StreamControllers following the existing pattern (see _afterHoursMatchController etc.):

```dart
// Save-related stream controllers
final _partnerSavedController = StreamController<Map<String, dynamic>>.broadcast();
final _matchSavedController = StreamController<Map<String, dynamic>>.broadcast();

// Stream getters
Stream<Map<String, dynamic>> get onPartnerSaved => _partnerSavedController.stream;
Stream<Map<String, dynamic>> get onMatchSaved => _matchSavedController.stream;
```

Add event listeners in _setupEventHandlers() method, following existing pattern:

```dart
// After Hours: Partner saved the match
_socket!.on('after_hours:partner_saved', (data) {
  debugPrint('Socket: Partner saved match');
  try {
    if (data is! Map<String, dynamic>) return;
    _partnerSavedController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing partner saved: $e');
  }
});

// After Hours: Match saved (mutual)
_socket!.on('after_hours:match_saved', (data) {
  debugPrint('Socket: Match saved (mutual)');
  try {
    if (data is! Map<String, dynamic>) return;
    _matchSavedController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing match saved: $e');
  }
});
```

Add controller cleanup in dispose() method:
```dart
_partnerSavedController.close();
_matchSavedController.close();
```

Event payload formats (from backend):
- after_hours:partner_saved: { matchId, savedBy, timestamp }
- after_hours:match_saved: { afterHoursMatchId, permanentMatchId, timestamp }
  </action>
  <verify>
```bash
grep -E "_partnerSavedController|_matchSavedController|after_hours:partner_saved|after_hours:match_saved" frontend/lib/services/socket_service.dart
```
All four patterns should appear.
  </verify>
  <done>
socket_service.dart has:
- _partnerSavedController and _matchSavedController stream controllers
- onPartnerSaved and onMatchSaved stream getters
- Event listeners for after_hours:partner_saved and after_hours:match_saved
- Controllers closed in dispose()
  </done>
</task>

<task type="auto">
  <name>Task 2: After Hours Chat Service saveMatch Method</name>
  <files>frontend/lib/services/after_hours_chat_service.dart</files>
  <action>
Extend after_hours_chat_service.dart with saveMatch method and SaveResult class.

Add SaveResult class at top of file (after imports):
```dart
/// Result of a save match attempt
class SaveResult {
  final bool success;
  final bool mutualSave;
  final String? permanentMatchId;
  final String? error;

  SaveResult({
    required this.success,
    this.mutualSave = false,
    this.permanentMatchId,
    this.error,
  });
}
```

Add saveMatch method to AfterHoursChatService class:
```dart
/// Save an After Hours match
/// Returns SaveResult with success, mutualSave flag, and optional permanentMatchId
Future<SaveResult> saveMatch({required String matchId}) async {
  try {
    final token = await _authService.getToken();
    if (token == null) {
      debugPrint('AfterHoursChatService: No auth token for save');
      return SaveResult(success: false, error: 'Not authenticated');
    }

    final uri = Uri.parse(
      '${AppConfig.chatServiceUrl}/api/after-hours/matches/$matchId/save',
    );

    final response = await http.post(
      uri,
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      return SaveResult(
        success: data['success'] == true,
        mutualSave: data['mutualSave'] == true,
        permanentMatchId: data['permanentMatchId'] as String?,
      );
    }

    if (response.statusCode == 404) {
      return SaveResult(success: false, error: 'Match not found');
    }
    if (response.statusCode == 403) {
      return SaveResult(success: false, error: 'Unauthorized');
    }

    return SaveResult(success: false, error: 'Failed to save match');
  } catch (e) {
    debugPrint('AfterHoursChatService: Error saving match: $e');
    return SaveResult(success: false, error: e.toString());
  }
}
```

This method:
- Uses existing _authService for token
- Calls POST /api/after-hours/matches/{matchId}/save
- Returns typed SaveResult for easy UI consumption
- Handles 404 (not found) and 403 (unauthorized) specifically
  </action>
  <verify>
```bash
grep -E "class SaveResult|saveMatch|after-hours/matches.*save" frontend/lib/services/after_hours_chat_service.dart
```
All three patterns should appear.

Run static analysis:
```bash
cd frontend && flutter analyze lib/services/after_hours_chat_service.dart 2>&1 | tail -5
```
  </verify>
  <done>
after_hours_chat_service.dart has:
- SaveResult class with success, mutualSave, permanentMatchId, error fields
- saveMatch method that calls POST /api/after-hours/matches/{matchId}/save
- Proper error handling for 404, 403, and other errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Save Match Button Widget</name>
  <files>frontend/lib/widgets/save_match_button.dart</files>
  <action>
Create new widget file for the SaveMatchButton with state machine.

State enum (determines button appearance and behavior):
```dart
enum SaveButtonState {
  /// User hasn't saved yet, button shows "Save Match"
  notSaved,
  /// Save request in progress
  saving,
  /// User saved, waiting for partner to save
  waitingForPartner,
  /// Partner saved first, urgent CTA to reciprocate
  partnerSavedFirst,
  /// Both saved, match is permanent
  mutualSaved,
}
```

Widget implementation:
```dart
import 'package:flutter/material.dart';

/// Button for saving an After Hours match
///
/// Shows different states based on save progress:
/// - notSaved: Active "Save Match" button
/// - saving: Loading indicator
/// - waitingForPartner: Disabled "Waiting for partner"
/// - partnerSavedFirst: Highlighted "Save to keep chatting!"
/// - mutualSaved: Disabled "Match saved!" with checkmark
class SaveMatchButton extends StatelessWidget {
  final SaveButtonState state;
  final VoidCallback? onSave;

  const SaveMatchButton({
    super.key,
    required this.state,
    this.onSave,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    switch (state) {
      case SaveButtonState.notSaved:
        return ElevatedButton.icon(
          onPressed: onSave,
          icon: const Icon(Icons.bookmark_border),
          label: const Text('Save Match'),
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.amber,
            foregroundColor: Colors.black87,
          ),
        );

      case SaveButtonState.saving:
        return ElevatedButton.icon(
          onPressed: null,
          icon: const SizedBox(
            width: 18,
            height: 18,
            child: CircularProgressIndicator(strokeWidth: 2),
          ),
          label: const Text('Saving...'),
        );

      case SaveButtonState.waitingForPartner:
        return ElevatedButton.icon(
          onPressed: null,
          icon: const Icon(Icons.bookmark, color: Colors.amber),
          label: const Text('Waiting for partner'),
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.grey.shade200,
            foregroundColor: Colors.grey.shade700,
          ),
        );

      case SaveButtonState.partnerSavedFirst:
        // Highlighted state - they saved first, prompt user to reciprocate
        return ElevatedButton.icon(
          onPressed: onSave,
          icon: const Icon(Icons.favorite, color: Colors.white),
          label: const Text('Save to keep chatting!'),
          style: ElevatedButton.styleFrom(
            backgroundColor: theme.colorScheme.primary,
            foregroundColor: Colors.white,
          ),
        );

      case SaveButtonState.mutualSaved:
        return ElevatedButton.icon(
          onPressed: null,
          icon: const Icon(Icons.check_circle, color: Colors.green),
          label: const Text('Match saved!'),
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.green.shade100,
            foregroundColor: Colors.green.shade800,
          ),
        );
    }
  }
}
```

Add library directive at top:
```dart
/// Save Match Button Widget
/// Displays save button with state-dependent appearance for After Hours chat
library;

import 'package:flutter/material.dart';
```

This widget is stateless - the parent (chat screen) manages the SaveButtonState based on:
- Initial API call to get current save state
- onPartnerSaved stream -> transition to partnerSavedFirst
- onMatchSaved stream -> transition to mutualSaved
- User tap -> transition to saving, then waitingForPartner or mutualSaved
  </action>
  <verify>
```bash
grep -E "enum SaveButtonState|class SaveMatchButton|notSaved|waitingForPartner|mutualSaved" frontend/lib/widgets/save_match_button.dart
```
All five patterns should appear.

Run static analysis:
```bash
cd frontend && flutter analyze lib/widgets/save_match_button.dart 2>&1 | tail -5
```
  </verify>
  <done>
save_match_button.dart file exists with:
- SaveButtonState enum with 5 states (notSaved, saving, waitingForPartner, partnerSavedFirst, mutualSaved)
- SaveMatchButton StatelessWidget
- Different button styles for each state
- partnerSavedFirst state has urgent styling to encourage save
  </done>
</task>

</tasks>

<verification>
1. Socket service has save event streams
2. Chat service has saveMatch method returning SaveResult
3. SaveMatchButton widget exists with all 5 states
4. All Dart files pass static analysis

```bash
cd frontend && flutter analyze lib/services/socket_service.dart lib/services/after_hours_chat_service.dart lib/widgets/save_match_button.dart 2>&1 | tail -10
```
</verification>

<success_criteria>
- [ ] socket_service.dart has onPartnerSaved and onMatchSaved streams
- [ ] after_hours_chat_service.dart has saveMatch method returning SaveResult
- [ ] save_match_button.dart exists with SaveButtonState enum and SaveMatchButton widget
- [ ] All 5 button states have distinct visual appearance
- [ ] partnerSavedFirst state shows urgent CTA
- [ ] All Dart files pass flutter analyze with no issues
</success_criteria>

<output>
After completion, create `.planning/phases/05-save-mechanism-conversion/05-02-SUMMARY.md`
</output>
