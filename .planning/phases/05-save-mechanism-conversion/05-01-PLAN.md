---
phase: 05-save-mechanism-conversion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/migrations/024_add_matches_source_column.sql
  - backend/chat-service/src/services/match-conversion-service.ts
  - backend/chat-service/src/routes/after-hours-chat.ts
  - backend/chat-service/src/socket/after-hours-handler.ts
  - backend/chat-service/src/services/fcm-service.ts
autonomous: true

must_haves:
  truths:
    - "User can vote to save an After Hours match"
    - "Second vote triggers mutual save detection"
    - "Mutual save converts ephemeral chat to permanent match"
    - "Messages are copied from after_hours_messages to messages table"
    - "Both users receive real-time notification on partner save and mutual save"
    - "Users not in app receive push notification when partner saves"
  artifacts:
    - path: "backend/migrations/024_add_matches_source_column.sql"
      provides: "source column for tracking match origin"
      contains: "ADD COLUMN.*source"
    - path: "backend/chat-service/src/services/match-conversion-service.ts"
      provides: "Atomic save vote and conversion logic"
      exports: ["recordSaveVote", "SaveVoteResult"]
    - path: "backend/chat-service/src/routes/after-hours-chat.ts"
      provides: "POST /after-hours/matches/:matchId/save endpoint"
      contains: "router.post.*save"
    - path: "backend/chat-service/src/socket/after-hours-handler.ts"
      provides: "Socket.IO events for save notifications"
      contains: "after_hours:partner_saved|after_hours:match_saved"
  key_links:
    - from: "routes/after-hours-chat.ts"
      to: "match-conversion-service.ts"
      via: "recordSaveVote function call"
      pattern: "recordSaveVote.*pool.*matchId.*userId"
    - from: "match-conversion-service.ts"
      to: "database"
      via: "SELECT...FOR UPDATE transaction"
      pattern: "FOR UPDATE"
    - from: "match-conversion-service.ts"
      to: "messages table"
      via: "INSERT INTO messages SELECT"
      pattern: "INSERT INTO messages.*SELECT.*after_hours_messages"
---

<objective>
Implement backend save vote endpoint with atomic mutual detection and match conversion.

Purpose: This is the critical path from ephemeral to persistent - when both users save, their ephemeral After Hours chat converts to a permanent match that persists after the session ends.

Output:
- Database migration adding `source` column to matches table
- Match conversion service with atomic save vote and conversion logic
- REST endpoint: POST /api/after-hours/matches/:matchId/save
- Socket.IO events: after_hours:partner_saved, after_hours:match_saved
- FCM push notifications for partner save and mutual save
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-save-mechanism-conversion/05-RESEARCH.md

# Existing code to extend/reference
@backend/chat-service/src/routes/after-hours-chat.ts
@backend/chat-service/src/socket/after-hours-handler.ts
@backend/chat-service/src/services/fcm-service.ts
@backend/chat-service/src/utils/id-generator.ts
@backend/migrations/021_add_after_hours_tables.sql
@backend/migrations/002_create_matches_and_messages.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database Migration for Match Source</name>
  <files>backend/migrations/024_add_matches_source_column.sql</files>
  <action>
Create migration file to add `source` column to existing `matches` table.

The matches table needs to track whether a match originated from:
- 'swipe' (default, regular matching)
- 'after_hours' (converted from After Hours ephemeral match)

SQL to implement:
```sql
-- Migration 024: Add source column to matches table
-- Description: Track match origin (swipe vs after_hours conversion)

ALTER TABLE matches ADD COLUMN IF NOT EXISTS source VARCHAR(50) DEFAULT 'swipe';

COMMENT ON COLUMN matches.source IS 'How the match was created: swipe (regular), after_hours (from After Hours mode)';

-- Index for filtering by source if needed
CREATE INDEX IF NOT EXISTS idx_matches_source ON matches(source);
```

This migration is safe to run on existing data - all existing matches get 'swipe' as default.
  </action>
  <verify>
Run migration dry run to verify syntax:
```bash
cd backend/migrations && psql $DATABASE_URL -c "\d matches" 2>/dev/null | grep -q source || echo "Column not yet added"
```
File exists with correct ALTER TABLE statement.
  </verify>
  <done>
Migration file exists at `backend/migrations/024_add_matches_source_column.sql` with:
- ALTER TABLE matches ADD COLUMN source VARCHAR(50) DEFAULT 'swipe'
- Comment explaining column purpose
- Index for source column
  </done>
</task>

<task type="auto">
  <name>Task 2: Match Conversion Service</name>
  <files>backend/chat-service/src/services/match-conversion-service.ts</files>
  <action>
Create new service file for atomic save vote recording and match conversion.

Key requirements from research:
1. Use SELECT...FOR UPDATE to lock the after_hours_match row (prevents race condition on simultaneous saves)
2. Check if already converted before doing work (idempotent)
3. Record vote in single transaction
4. If mutual save detected, perform conversion atomically:
   - Generate permanent match ID using existing generateMatchId()
   - Insert into matches table with source='after_hours'
   - Copy messages from after_hours_messages to messages table (with ORDER BY created_at)
   - Update after_hours_matches.converted_to_match_id

Interface to implement:
```typescript
interface SaveVoteResult {
  success: boolean;
  mutualSave: boolean;
  permanentMatchId?: string;
  alreadyVoted?: boolean;
  error?: string;
}
```

Export function `recordSaveVote(pool: Pool, afterHoursMatchId: string, userId: string): Promise<SaveVoteResult>`

Handle edge cases:
- Match not found: return { success: false, error: 'Match not found' }
- User not part of match: return { success: false, error: 'Unauthorized' }
- Already converted: return { success: true, mutualSave: true, permanentMatchId: existing, alreadyVoted: true }
- Already voted (not mutual yet): return { success: true, mutualSave: false, alreadyVoted: true }

Internal helper `convertToPermanentMatch(client: PoolClient, afterHoursMatchId: string, userId1: string, userId2: string): Promise<string>` for the conversion transaction.

Use generateMessageId() from existing id-generator.ts for new message IDs during copy.
  </action>
  <verify>
```bash
grep -E "recordSaveVote|FOR UPDATE|INSERT INTO messages.*SELECT" backend/chat-service/src/services/match-conversion-service.ts
```
All three patterns should be found.
  </verify>
  <done>
Service file exists with:
- SaveVoteResult interface exported
- recordSaveVote function with FOR UPDATE row lock
- convertToPermanentMatch helper that copies messages atomically
- All edge cases handled (not found, unauthorized, already converted, already voted)
  </done>
</task>

<task type="auto">
  <name>Task 3: Save Endpoint with Notifications</name>
  <files>
    backend/chat-service/src/routes/after-hours-chat.ts
    backend/chat-service/src/socket/after-hours-handler.ts
    backend/chat-service/src/services/fcm-service.ts
  </files>
  <action>
**Part A: Add save endpoint to after-hours-chat.ts**

Add POST /after-hours/matches/:matchId/save endpoint:
1. Validate matchId is UUID format (use existing UUID_REGEX)
2. Get userId from req.user!.userId
3. Call recordSaveVote(pool, matchId, userId)
4. On success, emit Socket.IO events and FCM push notifications
5. Return JSON response with save result

Response format:
```json
{
  "success": true,
  "mutualSave": false,
  "permanentMatchId": null
}
```

For Socket.IO emission, need access to io instance. The router receives pool - add io as second parameter to createAfterHoursChatRouter or use a module-level reference pattern.

**Part B: Add Socket.IO event emission helpers to after-hours-handler.ts**

Add exported helper functions (not part of socket connection handler, but utility functions):
```typescript
export function emitPartnerSaved(
  io: SocketServer,
  afterHoursMatchId: string,
  savingUserId: string,
  otherUserId: string
): void

export function emitMatchSaved(
  io: SocketServer,
  afterHoursMatchId: string,
  permanentMatchId: string,
  userId1: string,
  userId2: string
): void
```

Events to emit:
- `after_hours:partner_saved` to other user when first save occurs
- `after_hours:match_saved` to both users when mutual save

**Part C: Add FCM notification functions to fcm-service.ts**

Add two new exported functions following existing patterns (sendMessageNotification, sendMatchNotification):
```typescript
export async function sendAfterHoursPartnerSavedNotification(
  pool: Pool,
  recipientUserId: string,
  partnerName: string,
  afterHoursMatchId: string
): Promise<void>

export async function sendAfterHoursMutualSaveNotification(
  pool: Pool,
  recipientUserId: string,
  partnerName: string,
  permanentMatchId: string
): Promise<void>
```

Follow existing FCM patterns:
- Check isFirebaseReady()
- Get user tokens with getUserTokens()
- Use type field: 'after_hours_partner_saved', 'after_hours_match_saved'
- Android channel: 'after_hours' for partner saved, 'matches' for mutual save
- Handle invalid tokens with deactivateToken()

**Integration in save endpoint:**
After recordSaveVote returns:
1. If mutualSave=false and not alreadyVoted: emit after_hours:partner_saved, send partner saved FCM
2. If mutualSave=true and not alreadyVoted: emit after_hours:match_saved to both, send mutual save FCM to both

Need to query partner's name for FCM notifications. Query profiles table:
```sql
SELECT p.name FROM profiles p WHERE p.user_id = $1
```
  </action>
  <verify>
```bash
grep -E "router.post.*save|emitPartnerSaved|emitMatchSaved|sendAfterHoursPartnerSavedNotification|sendAfterHoursMutualSaveNotification" backend/chat-service/src/routes/after-hours-chat.ts backend/chat-service/src/socket/after-hours-handler.ts backend/chat-service/src/services/fcm-service.ts
```
All five patterns should be found across the three files.

Test endpoint structure:
```bash
grep -A 30 "router.post" backend/chat-service/src/routes/after-hours-chat.ts | head -40
```
  </verify>
  <done>
- POST /after-hours/matches/:matchId/save endpoint exists and calls recordSaveVote
- emitPartnerSaved and emitMatchSaved helper functions exported from after-hours-handler.ts
- sendAfterHoursPartnerSavedNotification and sendAfterHoursMutualSaveNotification added to fcm-service.ts
- Save endpoint emits Socket.IO events and FCM notifications on successful save
  </done>
</task>

</tasks>

<verification>
1. Migration file exists with correct schema
2. Match conversion service has atomic transaction with FOR UPDATE
3. Save endpoint returns correct response format
4. Socket.IO events are emitted on save
5. FCM notifications are sent for both partner save and mutual save

Manual verification (if database available):
```bash
# Check migration syntax
cd backend/migrations && cat 024_add_matches_source_column.sql

# Check service exports
cd backend/chat-service && npm run build 2>&1 | head -20

# Check endpoint registration
grep -r "after-hours" backend/chat-service/src/routes/
```
</verification>

<success_criteria>
- [ ] Migration file adds source column to matches table
- [ ] Match conversion service exports recordSaveVote with FOR UPDATE pattern
- [ ] Save endpoint at POST /after-hours/matches/:matchId/save
- [ ] Socket.IO events after_hours:partner_saved and after_hours:match_saved emitted
- [ ] FCM notifications sent for partner save and mutual save
- [ ] Atomic message copy from after_hours_messages to messages on conversion
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-save-mechanism-conversion/05-01-SUMMARY.md`
</output>
