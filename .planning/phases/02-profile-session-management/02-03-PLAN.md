---
phase: 02-profile-session-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/profile-service/package.json
  - backend/profile-service/src/services/session-scheduler.ts
  - backend/profile-service/src/routes/after-hours.ts
  - backend/profile-service/src/middleware/after-hours-validation.ts
autonomous: true
user_setup:
  - service: redis
    why: "BullMQ requires Redis for delayed job scheduling"
    env_vars:
      - name: REDIS_URL
        source: "Railway Dashboard -> Redis service -> Connection URL, OR use redis://localhost:6379 for local dev"
    dashboard_config: []

must_haves:
  truths:
    - "User can start a timed After Hours session (15, 30, or 60 min)"
    - "Session stores exact and fuzzed location"
    - "User cannot start session without After Hours profile"
    - "User cannot have multiple active sessions"
    - "User can check current session status"
    - "User can end session early"
    - "User can extend active session"
    - "Session expires automatically after duration"
  artifacts:
    - path: "backend/profile-service/src/services/session-scheduler.ts"
      provides: "BullMQ session expiry service"
      exports: ["scheduleSessionExpiry", "cancelSessionExpiry", "extendSessionExpiry", "initializeSessionWorker", "closeSessionScheduler"]
    - path: "backend/profile-service/src/routes/after-hours.ts"
      provides: "Session lifecycle endpoints"
      contains: "'/session'"
    - path: "backend/profile-service/src/middleware/after-hours-validation.ts"
      provides: "Session validation chains"
      exports: ["validateSessionStart", "validateSessionExtend"]
  key_links:
    - from: "backend/profile-service/src/routes/after-hours.ts"
      to: "backend/profile-service/src/services/session-scheduler.ts"
      via: "scheduleSessionExpiry import and call"
      pattern: "scheduleSessionExpiry"
    - from: "backend/profile-service/src/services/session-scheduler.ts"
      to: "after_hours_sessions table"
      via: "UPDATE query in worker"
      pattern: "UPDATE after_hours_sessions"
---

<objective>
Implement session lifecycle with BullMQ-based automatic expiry

Purpose: Users need to activate timed After Hours sessions to become discoverable. Sessions have fixed durations (15/30/60 min) and expire automatically. BullMQ handles reliable delayed job execution for session expiry even across server restarts.

Output:
- BullMQ session scheduler service (schedule, cancel, extend expiry)
- `/api/after-hours/session/start` POST endpoint
- `/api/after-hours/session/end` POST endpoint
- `/api/after-hours/session/extend` POST endpoint
- `/api/after-hours/session` GET endpoint (status)
- Automatic session expiry worker
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-profile-session-management/02-CONTEXT.md
@.planning/phases/02-profile-session-management/02-RESEARCH.md
@.planning/phases/02-profile-session-management/02-01-SUMMARY.md

@backend/profile-service/src/routes/after-hours.ts
@backend/profile-service/src/middleware/after-hours-validation.ts
@backend/profile-service/src/utils/location-fuzzer.ts
@backend/migrations/021_add_after_hours_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install BullMQ and ioredis dependencies</name>
  <files>backend/profile-service/package.json</files>
  <action>
Install BullMQ and ioredis for Redis-backed delayed jobs:

```bash
cd backend/profile-service && npm install bullmq ioredis
```

Also install types if not already present:
```bash
cd backend/profile-service && npm install --save-dev @types/ioredis
```

Note: ioredis types may be bundled with the package. If `@types/ioredis` fails to install, skip it (ioredis 5.x includes its own types).
  </action>
  <verify>
`package.json` includes bullmq and ioredis in dependencies
`npm ls bullmq` shows bullmq installed
  </verify>
  <done>
BullMQ and ioredis dependencies installed in profile-service
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session scheduler service with BullMQ</name>
  <files>backend/profile-service/src/services/session-scheduler.ts</files>
  <action>
Create the BullMQ-based session expiry service following patterns from RESEARCH.md:

```typescript
/**
 * Session Scheduler Service
 *
 * Uses BullMQ for reliable delayed job execution.
 * Handles session expiry, cancellation (early termination), and extension.
 *
 * IMPORTANT: Requires REDIS_URL environment variable.
 * In development: redis://localhost:6379
 * In production: Railway Redis connection URL
 */

import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { Pool } from 'pg';
import logger from '../utils/logger';

// Queue name constant
const QUEUE_NAME = 'after-hours-session-expiry';

// Module-level references for cleanup
let sessionExpiryQueue: Queue | null = null;
let sessionExpiryWorker: Worker | null = null;
let redisConnection: IORedis | null = null;

/**
 * Initialize the session scheduler (call on app startup)
 *
 * IMPORTANT: This function throws if Redis connection fails.
 * The calling code should handle this appropriately - either:
 * 1. Fail startup (recommended for production)
 * 2. Log and continue with degraded functionality (sessions won't auto-expire)
 */
export async function initializeSessionWorker(pool: Pool): Promise<void> {
  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

  // Create Redis connection
  redisConnection = new IORedis(redisUrl, {
    maxRetriesPerRequest: null, // Required by BullMQ
    enableReadyCheck: false,
  });

  // Wait for connection or error
  await new Promise<void>((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Redis connection timeout after 10 seconds'));
    }, 10000);

    redisConnection!.once('ready', () => {
      clearTimeout(timeout);
      logger.info('Redis connected for session scheduler', { url: redisUrl.replace(/:[^:@]+@/, ':***@') });
      resolve();
    });

    redisConnection!.once('error', (err) => {
      clearTimeout(timeout);
      reject(new Error(`Redis connection failed: ${err.message}`));
    });
  });

  redisConnection.on('error', (err) => {
    logger.error('Redis connection error (after initial connect)', { error: err.message });
  });

  // Create queue
  sessionExpiryQueue = new Queue(QUEUE_NAME, { connection: redisConnection });

  // Create worker to process expiry jobs
  sessionExpiryWorker = new Worker(
    QUEUE_NAME,
    async (job: Job) => {
      const { sessionId, userId } = job.data;

      logger.info('Processing session expiry job', { sessionId, userId, jobId: job.id });

      // End the session (set ended_at if not already ended)
      const result = await pool.query(
        `UPDATE after_hours_sessions
         SET ended_at = CURRENT_TIMESTAMP
         WHERE id = $1 AND ended_at IS NULL
         RETURNING id`,
        [sessionId]
      );

      if (result.rows.length > 0) {
        logger.info('Session expired by scheduler', { sessionId, userId });
        // TODO Phase 4: Emit Socket.IO event to notify user
      } else {
        logger.info('Session already ended, no action needed', { sessionId, userId });
      }
    },
    { connection: redisConnection }
  );

  sessionExpiryWorker.on('failed', (job, err) => {
    logger.error('Session expiry job failed', {
      jobId: job?.id,
      sessionId: job?.data?.sessionId,
      error: err.message,
    });
  });

  sessionExpiryWorker.on('completed', (job) => {
    logger.info('Session expiry job completed', {
      jobId: job.id,
      sessionId: job.data.sessionId,
    });
  });

  logger.info('Session scheduler initialized', { queue: QUEUE_NAME });
}

/**
 * Schedule a session to expire after the given delay
 */
export async function scheduleSessionExpiry(
  sessionId: string,
  userId: string,
  delayMs: number
): Promise<void> {
  if (!sessionExpiryQueue) {
    throw new Error('Session scheduler not initialized. Call initializeSessionWorker first.');
  }

  await sessionExpiryQueue.add(
    'expire',
    { sessionId, userId },
    {
      delay: delayMs,
      jobId: `session:expire:${sessionId}`, // Idempotency key
      removeOnComplete: true,
      removeOnFail: 100, // Keep last 100 failed for debugging
    }
  );

  logger.info('Scheduled session expiry', {
    sessionId,
    userId,
    delayMs,
    expiresIn: `${Math.round(delayMs / 60000)} minutes`,
  });
}

/**
 * Cancel a scheduled session expiry (for early termination)
 */
export async function cancelSessionExpiry(sessionId: string): Promise<void> {
  if (!sessionExpiryQueue) {
    logger.warn('Cannot cancel expiry: scheduler not initialized');
    return;
  }

  const jobId = `session:expire:${sessionId}`;
  const job = await sessionExpiryQueue.getJob(jobId);

  if (job) {
    await job.remove();
    logger.info('Cancelled session expiry job', { sessionId, jobId });
  } else {
    logger.info('No expiry job found to cancel', { sessionId, jobId });
  }
}

/**
 * Extend a session by rescheduling the expiry job
 */
export async function extendSessionExpiry(
  sessionId: string,
  userId: string,
  newDelayMs: number
): Promise<void> {
  // Cancel existing job and create new one
  await cancelSessionExpiry(sessionId);
  await scheduleSessionExpiry(sessionId, userId, newDelayMs);

  logger.info('Extended session expiry', {
    sessionId,
    userId,
    newDelayMs,
    newExpiresIn: `${Math.round(newDelayMs / 60000)} minutes`,
  });
}

/**
 * Gracefully close the scheduler (call on app shutdown)
 */
export async function closeSessionScheduler(): Promise<void> {
  if (sessionExpiryWorker) {
    await sessionExpiryWorker.close();
    sessionExpiryWorker = null;
  }

  if (sessionExpiryQueue) {
    await sessionExpiryQueue.close();
    sessionExpiryQueue = null;
  }

  if (redisConnection) {
    redisConnection.disconnect();
    redisConnection = null;
  }

  logger.info('Session scheduler closed');
}
```

Export all functions.
  </action>
  <verify>
File exists at `backend/profile-service/src/services/session-scheduler.ts`
TypeScript compiles: `cd backend/profile-service && npx tsc --noEmit`
Exports scheduleSessionExpiry, cancelSessionExpiry, extendSessionExpiry, initializeSessionWorker, closeSessionScheduler
  </verify>
  <done>
BullMQ session scheduler service created with schedule, cancel, extend, and graceful shutdown functions. Initialization now waits for Redis connection and throws on failure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add session validation and endpoints to router</name>
  <files>
backend/profile-service/src/middleware/after-hours-validation.ts
backend/profile-service/src/routes/after-hours.ts
backend/profile-service/src/index.ts
  </files>
  <action>
**Step 1: Add session validation chains to after-hours-validation.ts:**

```typescript
// Session start validation
export const validateSessionStart = [
  body('duration')
    .notEmpty()
    .withMessage('Duration is required')
    .isIn([15, 30, 60])
    .withMessage('Duration must be 15, 30, or 60 minutes'),
  body('latitude')
    .notEmpty()
    .withMessage('Latitude is required')
    .isFloat({ min: -90, max: 90 })
    .withMessage('Invalid latitude'),
  body('longitude')
    .notEmpty()
    .withMessage('Longitude is required')
    .isFloat({ min: -180, max: 180 })
    .withMessage('Invalid longitude'),
  handleValidationErrors
];

// Session extend validation
export const validateSessionExtend = [
  body('additionalMinutes')
    .notEmpty()
    .withMessage('Additional minutes required')
    .isIn([15, 30, 60])
    .withMessage('Can extend by 15, 30, or 60 minutes'),
  handleValidationErrors
];
```

**Step 2: Add session endpoints to after-hours.ts router:**

Import at top:
```typescript
import { fuzzLocationForAfterHours } from '../utils/location-fuzzer';
import {
  scheduleSessionExpiry,
  cancelSessionExpiry,
  extendSessionExpiry,
} from '../services/session-scheduler';
import { validateSessionStart, validateSessionExtend } from '../middleware/after-hours-validation';
```

Add endpoints:

**POST /session/start** - Start a new session:
```typescript
router.post('/session/start', validateSessionStart, async (req, res) => {
  const userId = req.user!.userId;
  const { duration, latitude, longitude } = req.body;

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Check user has After Hours profile (required before session)
    const profileCheck = await client.query(
      'SELECT user_id FROM after_hours_profiles WHERE user_id = $1',
      [userId]
    );
    if (profileCheck.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(400).json({
        success: false,
        error: 'After Hours profile required before starting session',
        code: 'PROFILE_REQUIRED'
      });
    }

    // Check for existing active session
    const existingSession = await client.query(
      `SELECT id FROM after_hours_sessions
       WHERE user_id = $1 AND ended_at IS NULL`,
      [userId]
    );
    if (existingSession.rows.length > 0) {
      await client.query('ROLLBACK');
      return res.status(409).json({
        success: false,
        error: 'Active session already exists',
        code: 'SESSION_ALREADY_ACTIVE'
      });
    }

    // Fuzz location for privacy
    const fuzzed = fuzzLocationForAfterHours(latitude, longitude);

    // Calculate expiry time
    const durationMinutes = duration;
    const expiresAt = new Date(Date.now() + durationMinutes * 60 * 1000);

    // Create session
    const result = await client.query(
      `INSERT INTO after_hours_sessions
       (user_id, expires_at, latitude, longitude, fuzzed_latitude, fuzzed_longitude)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING id, started_at, expires_at`,
      [userId, expiresAt, latitude, longitude, fuzzed.latitude, fuzzed.longitude]
    );

    await client.query('COMMIT');

    const session = result.rows[0];

    // Schedule expiry job (fire-and-forget, session persists regardless)
    scheduleSessionExpiry(session.id, userId, durationMinutes * 60 * 1000).catch(err => {
      logger.error('Failed to schedule session expiry', { sessionId: session.id, error: err.message });
    });

    logger.info('Session started', {
      userId,
      sessionId: session.id,
      durationMinutes,
      expiresAt: session.expires_at,
    });

    res.status(201).json({
      success: true,
      session: {
        id: session.id,
        startedAt: session.started_at,
        expiresAt: session.expires_at,
        durationMinutes,
      }
    });
  } catch (error: any) {
    await client.query('ROLLBACK');
    logger.error('Failed to start session', { error: error.message, userId });
    res.status(500).json({ success: false, error: 'Failed to start session' });
  } finally {
    client.release();
  }
});
```

**POST /session/end** - End session early:
```typescript
router.post('/session/end', async (req, res) => {
  const userId = req.user!.userId;

  const result = await pool.query(
    `UPDATE after_hours_sessions
     SET ended_at = CURRENT_TIMESTAMP
     WHERE user_id = $1 AND ended_at IS NULL
     RETURNING id`,
    [userId]
  );

  if (result.rows.length === 0) {
    return res.status(404).json({
      success: false,
      error: 'No active session found'
    });
  }

  const sessionId = result.rows[0].id;

  // Cancel the scheduled expiry job
  cancelSessionExpiry(sessionId).catch(err => {
    logger.error('Failed to cancel session expiry', { sessionId, error: err.message });
  });

  logger.info('Session ended early', { userId, sessionId });

  res.json({
    success: true,
    message: 'Session ended'
  });
});
```

**POST /session/extend** - Extend active session:
```typescript
router.post('/session/extend', validateSessionExtend, async (req, res) => {
  const userId = req.user!.userId;
  const { additionalMinutes } = req.body;

  // Get current active session
  const sessionResult = await pool.query(
    `SELECT id, expires_at FROM after_hours_sessions
     WHERE user_id = $1 AND ended_at IS NULL`,
    [userId]
  );

  if (sessionResult.rows.length === 0) {
    return res.status(404).json({
      success: false,
      error: 'No active session to extend'
    });
  }

  const session = sessionResult.rows[0];
  const currentExpiry = new Date(session.expires_at);
  const newExpiry = new Date(currentExpiry.getTime() + additionalMinutes * 60 * 1000);
  const remainingMs = newExpiry.getTime() - Date.now();

  // Update session expiry
  await pool.query(
    `UPDATE after_hours_sessions SET expires_at = $1 WHERE id = $2`,
    [newExpiry, session.id]
  );

  // Reschedule the expiry job
  extendSessionExpiry(session.id, userId, remainingMs).catch(err => {
    logger.error('Failed to extend session expiry', { sessionId: session.id, error: err.message });
  });

  logger.info('Session extended', {
    userId,
    sessionId: session.id,
    additionalMinutes,
    newExpiry,
  });

  res.json({
    success: true,
    session: {
      id: session.id,
      expiresAt: newExpiry,
      extendedByMinutes: additionalMinutes,
    }
  });
});
```

**GET /session** - Get current session status:
```typescript
router.get('/session', async (req, res) => {
  const userId = req.user!.userId;

  const result = await pool.query(
    `SELECT id, started_at, expires_at,
            EXTRACT(EPOCH FROM (expires_at - NOW())) AS remaining_seconds
     FROM after_hours_sessions
     WHERE user_id = $1 AND ended_at IS NULL`,
    [userId]
  );

  if (result.rows.length === 0) {
    return res.json({
      success: true,
      active: false,
      session: null
    });
  }

  const session = result.rows[0];
  const remainingSeconds = Math.max(0, Math.floor(session.remaining_seconds));

  res.json({
    success: true,
    active: remainingSeconds > 0,
    session: {
      id: session.id,
      startedAt: session.started_at,
      expiresAt: session.expires_at,
      remainingSeconds,
    }
  });
});
```

**Step 3: Initialize session worker in index.ts:**

Add import:
```typescript
import { initializeSessionWorker, closeSessionScheduler } from './services/session-scheduler';
```

After pool initialization, add (with proper error handling):
```typescript
// Initialize session scheduler (BullMQ)
// In production, consider making this fatal (process.exit(1)) if Redis is required
try {
  await initializeSessionWorker(pool);
  logger.info('Session scheduler initialized successfully');
} catch (err: any) {
  logger.error('Failed to initialize session scheduler - sessions will NOT auto-expire', {
    error: err.message,
    hint: 'Ensure REDIS_URL is set and Redis is accessible'
  });
  // Continue startup - sessions will still work but won't auto-expire
  // For stricter behavior, uncomment: process.exit(1);
}
```

Before server starts, add graceful shutdown:
```typescript
// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  await closeSessionScheduler();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');
  await closeSessionScheduler();
  process.exit(0);
});
```
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npx tsc --noEmit`

Start server with Redis and verify connection:
```bash
# Ensure Redis is running locally or REDIS_URL is set
cd backend/profile-service && npm run dev
# Look for: "Redis connected for session scheduler" in logs
# If Redis unavailable, expect: "Failed to initialize session scheduler" warning
```

**Redis connection verification checklist:**
1. If Redis available: Should see "Redis connected for session scheduler" followed by "Session scheduler initialized successfully"
2. If Redis unavailable: Should see "Failed to initialize session scheduler - sessions will NOT auto-expire" with hint about REDIS_URL

Session endpoints exist in router.
  </verify>
  <done>
Session lifecycle endpoints implemented: start, end, extend, status. BullMQ worker initialization now properly awaits Redis connection and logs success/failure clearly. Graceful shutdown handlers added.
  </done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```bash
cd backend/profile-service && npx tsc --noEmit
```

Run existing tests:
```bash
cd backend/profile-service && npm test
```

Start server with Redis (requires Redis running):
```bash
# Start Redis locally (if not using Railway)
docker run -d -p 6379:6379 redis:alpine

# Or use Railway Redis and set REDIS_URL

cd backend/profile-service && npm run dev
# Look for: "Redis connected for session scheduler"
# Followed by: "Session scheduler initialized successfully"
```

**Verify Redis connection behavior:**
```bash
# With Redis running - expect success logs
REDIS_URL=redis://localhost:6379 npm run dev

# Without Redis - expect warning logs (server still starts)
REDIS_URL=redis://nonexistent:6379 npm run dev
# Should see: "Failed to initialize session scheduler - sessions will NOT auto-expire"
```

Manual testing (requires JWT and database):
```bash
# Check session status (should return active: false)
curl http://localhost:3002/api/after-hours/session -H "Authorization: Bearer <jwt>"

# Start session (will fail 403 without premium, but confirms route exists)
curl -X POST http://localhost:3002/api/after-hours/session/start \
  -H "Authorization: Bearer <jwt>" \
  -H "Content-Type: application/json" \
  -d '{"duration":30,"latitude":52.520,"longitude":13.405}'
```
</verification>

<success_criteria>
1. BullMQ and ioredis installed
2. TypeScript compiles without errors
3. Server starts and logs Redis connection result clearly (success or failure with hint)
4. POST /api/after-hours/session/start creates session with fuzzed location
5. GET /api/after-hours/session returns session status
6. POST /api/after-hours/session/end ends session and cancels expiry job
7. POST /api/after-hours/session/extend extends session and reschedules expiry
8. Session expiry job fires after duration (test with short duration)
</success_criteria>

<output>
After completion, create `.planning/phases/02-profile-session-management/02-03-SUMMARY.md`
</output>
