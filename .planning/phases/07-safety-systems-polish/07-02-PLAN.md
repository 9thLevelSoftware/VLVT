---
phase: 07-safety-systems-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/profile-service/src/services/photo-hash-service.ts
  - backend/profile-service/src/utils/device-fingerprint.ts
  - backend/profile-service/src/routes/after-hours.ts
  - backend/migrations/007_ban_enforcement.sql
autonomous: true

must_haves:
  truths:
    - "Device fingerprint is stored when After Hours session starts"
    - "Photo hash is computed and stored when After Hours photo is uploaded"
    - "Photo upload fails if hash matches a banned photo"
  artifacts:
    - path: "backend/profile-service/src/services/photo-hash-service.ts"
      provides: "Perceptual hashing with sharp-phash"
      exports: ["computePhotoHash", "checkBannedPhoto"]
    - path: "backend/profile-service/src/utils/device-fingerprint.ts"
      provides: "Device fingerprint storage utilities"
      exports: ["storeDeviceFingerprint"]
    - path: "backend/migrations/007_ban_enforcement.sql"
      provides: "Database tables for banned_photo_hashes and device_fingerprints"
      contains: "CREATE TABLE banned_photo_hashes"
  key_links:
    - from: "backend/profile-service/src/routes/after-hours.ts"
      to: "photo-hash-service.ts"
      via: "computePhotoHash call on photo upload"
      pattern: "computePhotoHash"
    - from: "backend/profile-service/src/routes/after-hours.ts"
      to: "device-fingerprint.ts"
      via: "storeDeviceFingerprint call on session start"
      pattern: "storeDeviceFingerprint"
---

<objective>
Add device fingerprinting and photo perceptual hashing infrastructure for ban enforcement.

Purpose: Detect ban evaders by matching device IDs and photo hashes against known banned users. Store fingerprints at session start and hashes at photo upload.

Output: New migration for tables, photo hash service, device fingerprint utility, wiring into existing routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-safety-systems-polish/07-RESEARCH.md

# Existing patterns
@backend/profile-service/src/routes/after-hours.ts
@backend/profile-service/src/utils/image-handler.ts (existing Sharp pipeline)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ban Enforcement Migration</name>
  <files>backend/migrations/007_ban_enforcement.sql</files>
  <action>
Create a new migration file with two tables:

```sql
-- Device fingerprints collected at session start
CREATE TABLE IF NOT EXISTS device_fingerprints (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES after_hours_sessions(id) ON DELETE SET NULL,
  device_id VARCHAR(255),           -- IDFV (iOS) or Android ID
  device_model VARCHAR(100),        -- e.g., "iPhone14,3"
  platform VARCHAR(20),             -- 'ios' or 'android'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_device_fingerprints_user ON device_fingerprints(user_id);
CREATE INDEX idx_device_fingerprints_device ON device_fingerprints(device_id);

-- Photo hashes for banned users (perceptual hash)
CREATE TABLE IF NOT EXISTS banned_photo_hashes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  photo_hash VARCHAR(16) NOT NULL,  -- 64-bit hex string from sharp-phash
  user_id VARCHAR(255),             -- Optional: user who was banned (for audit)
  reason TEXT,                      -- Why this hash was banned
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_banned_photo_hashes_hash ON banned_photo_hashes(photo_hash);

-- After Hours profile photo hashes (for tracking, not enforcement)
ALTER TABLE after_hours_profiles
ADD COLUMN IF NOT EXISTS photo_hash VARCHAR(16);
```

Follow existing migration file naming convention (see backend/migrations/).
  </action>
  <verify>SQL syntax is valid (no runtime test needed for planning)</verify>
  <done>Migration file exists with both tables and index definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create Photo Hash Service</name>
  <files>backend/profile-service/src/services/photo-hash-service.ts</files>
  <action>
Create a new service file using sharp-phash:

1. Install dependency: `npm install sharp-phash` in profile-service

2. Create service with exports:

```typescript
import sharp from 'sharp';
import phash from 'sharp-phash';
import { Pool } from 'pg';
import logger from '../utils/logger';

/**
 * Compute perceptual hash for an image buffer
 * Returns 64-bit hex string (16 chars)
 */
export async function computePhotoHash(imageBuffer: Buffer): Promise<string> {
  const image = sharp(imageBuffer);
  const hash = await phash(image);
  return hash;
}

/**
 * Calculate Hamming distance between two hashes
 * Lower distance = more similar images
 */
export function hammingDistance(hash1: string, hash2: string): number {
  let distance = 0;
  const h1 = BigInt('0x' + hash1);
  const h2 = BigInt('0x' + hash2);
  let xor = h1 ^ h2;
  while (xor > 0n) {
    distance += Number(xor & 1n);
    xor >>= 1n;
  }
  return distance;
}

/**
 * Check if a photo hash matches any banned hashes
 * Threshold: distance < 10 is considered a match
 * Returns { isBanned: boolean, matchedHash?: string }
 */
export async function checkBannedPhoto(
  pool: Pool,
  photoHash: string,
  threshold: number = 10
): Promise<{ isBanned: boolean; matchedHash?: string }> {
  const result = await pool.query('SELECT photo_hash FROM banned_photo_hashes');

  for (const row of result.rows) {
    const distance = hammingDistance(photoHash, row.photo_hash);
    if (distance < threshold) {
      logger.warn('Banned photo hash match detected', {
        uploadedHash: photoHash,
        bannedHash: row.photo_hash,
        distance,
      });
      return { isBanned: true, matchedHash: row.photo_hash };
    }
  }

  return { isBanned: false };
}
```

Use threshold of 10 bits (configurable) - images with less than 10 bits different are considered matches.
  </action>
  <verify>`cd backend/profile-service && npm run build` compiles</verify>
  <done>Photo hash service exists with three exported functions</done>
</task>

<task type="auto">
  <name>Task 3: Create Device Fingerprint Utility and Wire Into Routes</name>
  <files>
    backend/profile-service/src/utils/device-fingerprint.ts
    backend/profile-service/src/routes/after-hours.ts
  </files>
  <action>
1. Create device-fingerprint.ts:

```typescript
import { Pool } from 'pg';
import logger from './logger';

export interface DeviceFingerprint {
  deviceId?: string;    // IDFV or Android ID
  deviceModel?: string; // Device model name
  platform?: string;    // 'ios' or 'android'
}

/**
 * Store device fingerprint at session start
 * Non-blocking: errors are logged but don't fail the request
 */
export async function storeDeviceFingerprint(
  pool: Pool,
  userId: string,
  sessionId: string,
  fingerprint: DeviceFingerprint
): Promise<void> {
  try {
    await pool.query(
      `INSERT INTO device_fingerprints (user_id, session_id, device_id, device_model, platform)
       VALUES ($1, $2, $3, $4, $5)`,
      [
        userId,
        sessionId,
        fingerprint.deviceId || null,
        fingerprint.deviceModel || null,
        fingerprint.platform || null,
      ]
    );
    logger.info('Device fingerprint stored', { userId, sessionId });
  } catch (error: any) {
    // Non-blocking: log but don't fail
    logger.warn('Failed to store device fingerprint', {
      userId,
      sessionId,
      error: error.message,
    });
  }
}
```

2. Modify after-hours.ts POST /session/start:
   - Accept optional `deviceFingerprint` in request body: `{ deviceId?, deviceModel?, platform? }`
   - After session insert succeeds, call `storeDeviceFingerprint()` (fire-and-forget)
   - Do NOT await the fingerprint storage - session start should not be blocked

3. Modify after-hours.ts POST /profile/photo:
   - After image processing but before R2 upload, call `computePhotoHash()`
   - Call `checkBannedPhoto()` - if banned, return 403 with error "Photo not allowed"
   - If not banned, store hash in `after_hours_profiles.photo_hash` column
   - Continue with existing upload flow

Import the new services at top of file:
```typescript
import { computePhotoHash, checkBannedPhoto } from '../services/photo-hash-service';
import { storeDeviceFingerprint } from '../utils/device-fingerprint';
```
  </action>
  <verify>
    `cd backend/profile-service && npm run build` compiles
    Photo upload endpoint includes hash check
    Session start endpoint accepts fingerprint
  </verify>
  <done>
    Device fingerprint utility created
    Session start accepts and stores fingerprint (non-blocking)
    Photo upload computes hash and checks against banned list
  </done>
</task>

</tasks>

<verification>
1. `cd backend/profile-service && npm install sharp-phash` succeeds
2. `cd backend/profile-service && npm run build` compiles without errors
3. Migration file contains valid SQL
4. Photo hash service exports all three functions
5. Session start endpoint accepts deviceFingerprint body parameter
6. Photo upload endpoint returns 403 for banned photos
</verification>

<success_criteria>
- Migration 007 exists with device_fingerprints and banned_photo_hashes tables
- photo-hash-service.ts computes perceptual hashes using sharp-phash
- device-fingerprint.ts stores fingerprints non-blocking
- Session start wired to fingerprint storage
- Photo upload wired to hash computation and ban check
</success_criteria>

<output>
After completion, create `.planning/phases/07-safety-systems-polish/07-02-SUMMARY.md`
</output>
