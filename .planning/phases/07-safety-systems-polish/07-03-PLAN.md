---
phase: 07-safety-systems-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/profile-service/src/jobs/session-cleanup-job.ts
  - backend/profile-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Expired sessions are cleaned up automatically"
    - "Orphaned After Hours data (profiles without users) is cleaned"
    - "Cleanup runs daily at 4 AM UTC (1 hour after message cleanup)"
  artifacts:
    - path: "backend/profile-service/src/jobs/session-cleanup-job.ts"
      provides: "BullMQ job for session and orphan cleanup"
      exports: ["initializeSessionCleanupJob", "closeSessionCleanupJob"]
  key_links:
    - from: "backend/profile-service/src/index.ts"
      to: "session-cleanup-job.ts"
      via: "initializeSessionCleanupJob call on startup"
      pattern: "initializeSessionCleanupJob"
---

<objective>
Add scheduled cleanup jobs for expired sessions and orphaned After Hours data.

Purpose: Prevent data accumulation from sessions that were never properly ended, and clean up orphaned records. Complements existing message-cleanup-job in chat-service.

Output: New BullMQ job in profile-service, wired to app startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-safety-systems-polish/07-RESEARCH.md

# Existing patterns
@backend/chat-service/src/jobs/message-cleanup-job.ts (BullMQ pattern to follow)
@backend/profile-service/src/services/session-scheduler.ts (existing session management)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Session Cleanup Job</name>
  <files>backend/profile-service/src/jobs/session-cleanup-job.ts</files>
  <action>
Create a new BullMQ job following the exact pattern from message-cleanup-job.ts:

```typescript
/**
 * Session Cleanup Job
 *
 * Scheduled BullMQ job that runs daily at 4 AM UTC to clean up:
 * 1. Expired sessions that weren't properly ended (ended_at still NULL)
 * 2. Session decline records older than 7 days
 * 3. Device fingerprints for sessions that no longer exist
 *
 * Runs 1 hour after message cleanup to ensure messages are cleaned first.
 */

import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { Pool } from 'pg';
import logger from '../utils/logger';

const CLEANUP_QUEUE_NAME = 'after-hours-session-cleanup';
const SESSION_RETENTION_DAYS = 7;  // Keep ended sessions for 7 days

let cleanupQueue: Queue | null = null;
let cleanupWorker: Worker | null = null;
let redisConnection: IORedis | null = null;

export async function initializeSessionCleanupJob(pool: Pool): Promise<void> {
  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

  try {
    redisConnection = new IORedis(redisUrl, {
      maxRetriesPerRequest: null,
      enableReadyCheck: false,
    });

    // Wait for connection with timeout
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        redisConnection?.disconnect();
        reject(new Error('Redis connection timeout after 10 seconds'));
      }, 10000);

      redisConnection!.once('ready', () => {
        clearTimeout(timeout);
        logger.info('Redis connected for session cleanup job');
        resolve();
      });

      redisConnection!.once('error', (err) => {
        clearTimeout(timeout);
        reject(err);
      });
    });

    redisConnection.on('error', (err) => {
      logger.error('Redis connection error (session cleanup)', { error: err.message });
    });

    cleanupQueue = new Queue(CLEANUP_QUEUE_NAME, { connection: redisConnection });

    // Schedule daily cleanup at 4 AM UTC (1 hour after message cleanup)
    await cleanupQueue.upsertJobScheduler(
      'daily-session-cleanup',
      { pattern: '0 4 * * *' },
      { name: 'cleanup-expired-sessions', data: {} }
    );

    cleanupWorker = new Worker(
      CLEANUP_QUEUE_NAME,
      async (job: Job) => {
        if (job.name === 'cleanup-expired-sessions') {
          await cleanupExpiredSessions(pool);
        }
      },
      { connection: redisConnection }
    );

    cleanupWorker.on('failed', (job, err) => {
      logger.error('Session cleanup job failed', { jobId: job?.id, error: err.message });
    });

    cleanupWorker.on('completed', (job) => {
      logger.info('Session cleanup job completed', { jobId: job.id });
    });

    logger.info('Session cleanup job scheduled', {
      schedule: '4 AM UTC daily',
      retentionDays: SESSION_RETENTION_DAYS,
    });
  } catch (error: any) {
    logger.warn('Failed to initialize session cleanup job', { error: error.message });
    // Non-blocking: server continues without cleanup job
  }
}

async function cleanupExpiredSessions(pool: Pool): Promise<void> {
  try {
    // 1. Clean up sessions that expired but were never ended
    const expiredSessions = await pool.query(
      `UPDATE after_hours_sessions
       SET ended_at = expires_at
       WHERE ended_at IS NULL
         AND expires_at < NOW()
       RETURNING id`
    );

    // 2. Delete old decline records (older than 7 days)
    const oldDeclines = await pool.query(
      `DELETE FROM after_hours_declines
       WHERE created_at < NOW() - INTERVAL '${SESSION_RETENTION_DAYS} days'
       RETURNING id`
    );

    // 3. Delete orphaned device fingerprints (session no longer exists)
    const orphanedFingerprints = await pool.query(
      `DELETE FROM device_fingerprints
       WHERE session_id IS NOT NULL
         AND session_id NOT IN (SELECT id FROM after_hours_sessions)
       RETURNING id`
    );

    logger.info('Session cleanup completed', {
      expiredSessionsClosed: expiredSessions.rows.length,
      oldDeclinesDeleted: oldDeclines.rows.length,
      orphanedFingerprintsDeleted: orphanedFingerprints.rows.length,
    });
  } catch (error: any) {
    logger.error('Failed to cleanup sessions', { error: error.message });
    throw error;
  }
}

export async function closeSessionCleanupJob(): Promise<void> {
  if (cleanupWorker) {
    await cleanupWorker.close();
    cleanupWorker = null;
  }

  if (cleanupQueue) {
    await cleanupQueue.close();
    cleanupQueue = null;
  }

  if (redisConnection) {
    redisConnection.disconnect();
    redisConnection = null;
  }

  logger.info('Session cleanup job closed');
}
```

Key differences from message-cleanup:
- Runs at 4 AM (1 hour after messages)
- Cleans sessions, declines, and fingerprints
- Does not delete matches (those are in chat-service domain)
  </action>
  <verify>`cd backend/profile-service && npm run build` compiles</verify>
  <done>Session cleanup job exists with same BullMQ pattern as message cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Wire Cleanup Job to App Startup</name>
  <files>backend/profile-service/src/index.ts</files>
  <action>
Add the cleanup job initialization to profile-service startup:

1. Import at top of file:
```typescript
import { initializeSessionCleanupJob, closeSessionCleanupJob } from './jobs/session-cleanup-job';
```

2. In the startup sequence (after pool is created, around where session-scheduler is initialized):
```typescript
// Initialize session cleanup job (non-blocking)
initializeSessionCleanupJob(pool).catch(err => {
  logger.warn('Session cleanup job initialization failed', { error: err.message });
});
```

3. In graceful shutdown handler (if one exists, or add one):
```typescript
// In shutdown handler:
await closeSessionCleanupJob();
```

Look for existing shutdown patterns in the file. If there's a SIGTERM/SIGINT handler, add the close call there.

If no shutdown handler exists, create a minimal one:
```typescript
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  await closeSessionCleanupJob();
  await pool.end();
  process.exit(0);
});
```
  </action>
  <verify>
    `cd backend/profile-service && npm run build` compiles
    Startup logs show session cleanup scheduled (verify in dev)
  </verify>
  <done>Session cleanup job initialized on startup and closed on shutdown</done>
</task>

</tasks>

<verification>
1. `cd backend/profile-service && npm run build` compiles without errors
2. session-cleanup-job.ts exists in jobs/ directory
3. Job scheduled for 4 AM UTC daily (1 hour after message cleanup)
4. Startup wires initialization, shutdown wires close
5. Non-blocking pattern maintained (server starts even if Redis fails)
</verification>

<success_criteria>
- Session cleanup job runs daily at 4 AM UTC
- Expired sessions get ended_at set to expires_at
- Decline records older than 7 days are deleted
- Orphaned device fingerprints are cleaned
- Job initialization is non-blocking (server continues if Redis unavailable)
</success_criteria>

<output>
After completion, create `.planning/phases/07-safety-systems-polish/07-03-SUMMARY.md`
</output>
