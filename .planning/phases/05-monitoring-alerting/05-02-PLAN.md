---
phase: 05-monitoring-alerting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/auth-service/src/index.ts
  - backend/profile-service/src/index.ts
  - backend/chat-service/src/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Health endpoint returns database connectivity status"
    - "Health endpoint returns 503 when database is unreachable"
    - "Health endpoint includes response latency for dependency checks"
    - "Health endpoint returns service version"
  artifacts:
    - path: "backend/auth-service/src/index.ts"
      provides: "Enhanced /health endpoint with dependency checks"
      contains: "checks.*database"
    - path: "backend/profile-service/src/index.ts"
      provides: "Enhanced /health endpoint with dependency checks"
      contains: "checks.*database"
    - path: "backend/chat-service/src/index.ts"
      provides: "Enhanced /health endpoint with dependency checks"
      contains: "checks.*database"
  key_links:
    - from: "/health endpoint"
      to: "PostgreSQL pool"
      via: "SELECT 1 query"
      pattern: "pool\\.query.*SELECT 1"
---

<objective>
Enrich health check endpoints with database dependency status across all services.

Purpose: Health checks that only return `{ status: 'ok' }` hide downstream failures. Enhanced health checks enable detection of degraded state before full service outage, helping uptime monitors distinguish between service crashes and dependency issues.

Output: Health endpoints that check database connectivity, report latency, and return 503 for degraded state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-monitoring-alerting/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance health endpoints in all three services</name>
  <files>backend/auth-service/src/index.ts, backend/profile-service/src/index.ts, backend/chat-service/src/index.ts</files>
  <action>
For each service, replace the existing simple health check with an enhanced version that checks database connectivity.

**Current pattern (in all services):**
```typescript
app.get('/health', (req: Request, res: Response) => {
  res.json(addVersionToHealth({ status: 'ok', service: 'xxx-service' }));
});
```

**Replace with enhanced health check:**

```typescript
// Health check endpoint with dependency status (MON-02)
app.get('/health', async (req: Request, res: Response) => {
  const startTime = Date.now();
  const serviceName = 'auth-service'; // or profile-service, chat-service

  const health = {
    status: 'ok' as 'ok' | 'degraded' | 'unhealthy',
    service: serviceName,
    timestamp: new Date().toISOString(),
    checks: {
      database: { status: 'unknown' as string, latencyMs: -1 },
    },
  };

  // Check database connectivity
  try {
    const dbStart = Date.now();
    await pool.query('SELECT 1');
    health.checks.database = {
      status: 'ok',
      latencyMs: Date.now() - dbStart,
    };
  } catch (err) {
    health.checks.database = {
      status: 'error',
      latencyMs: -1,
    };
    health.status = 'degraded';
    // Log but don't expose error details
    logger.error('Health check: database connectivity failed', {
      error: err instanceof Error ? err.message : 'Unknown error',
    });
  }

  // Return appropriate status code
  const httpStatus = health.status === 'ok' ? 200 : 503;
  res.status(httpStatus).json(addVersionToHealth(health));
});
```

**Important notes:**
1. The `pool` variable already exists in each service (PostgreSQL connection pool)
2. The `logger` variable already exists in each service
3. The `addVersionToHealth` function is already imported from `@vlvt/shared`
4. Make the handler `async` to allow `await pool.query()`
5. Use appropriate service name for each file

**For chat-service only:** Also check Redis connectivity if available (chat-service uses Redis for Socket.IO adapter). Add an optional Redis check:

```typescript
// Optional: Check Redis connectivity (chat-service only)
if (typeof redisAdapter !== 'undefined') {
  try {
    const redisStart = Date.now();
    // Redis adapter health check - just verify it exists
    health.checks.redis = {
      status: 'ok',
      latencyMs: Date.now() - redisStart,
    };
  } catch (err) {
    health.checks.redis = {
      status: 'error',
      latencyMs: -1,
    };
    // Redis being down is degraded, not unhealthy (graceful degradation)
    if (health.status === 'ok') {
      health.status = 'degraded';
    }
  }
}
```

Note: Only add Redis check if the service actually uses Redis. Check if `redisAdapter` or similar Redis client exists in the service before adding this check.
  </action>
  <verify>
For each service:
1. `npm run build` compiles without errors
2. `npm run dev` starts the service (if possible in local env)
3. `curl http://localhost:PORT/health` returns JSON with `checks.database` object
4. Response includes `latencyMs` field
5. Response includes `timestamp` field
  </verify>
  <done>
All three services have health endpoints that:
- Check database connectivity via `SELECT 1`
- Return latency for each dependency check
- Return 503 status code when database is unreachable
- Include timestamp for monitoring cache detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types for health check response</name>
  <files>backend/auth-service/src/index.ts, backend/profile-service/src/index.ts, backend/chat-service/src/index.ts</files>
  <action>
Add inline TypeScript types for the health check response to ensure type safety. This can be done at the top of the health check handler or as a local interface:

```typescript
interface HealthCheckResult {
  status: 'ok' | 'degraded' | 'unhealthy';
  service: string;
  timestamp: string;
  checks: {
    database: { status: string; latencyMs: number };
    redis?: { status: string; latencyMs: number };
  };
}
```

This is optional if TypeScript infers the types correctly, but recommended for maintainability.

Also ensure the return type is explicitly `Promise<void>` for the async handler to avoid implicit any:

```typescript
app.get('/health', async (req: Request, res: Response): Promise<void> => {
  // ... handler code
});
```
  </action>
  <verify>
`npm run build` in each service shows no TypeScript errors related to health endpoint.
  </verify>
  <done>
Health endpoint handlers have proper TypeScript typing.
  </done>
</task>

</tasks>

<verification>
1. `cd backend/auth-service && npm run build` - compiles
2. `cd backend/profile-service && npm run build` - compiles
3. `cd backend/chat-service && npm run build` - compiles
4. Each service's /health endpoint:
   - Returns `checks.database` object
   - Returns `latencyMs` for database check
   - Returns `timestamp` field
   - Returns HTTP 200 when healthy
   - Would return HTTP 503 when database unreachable (tested via comment or manual disconnect)
</verification>

<success_criteria>
- All 3 services have enhanced /health endpoints
- Health response includes database connectivity check
- Health response includes latency metrics
- Health response returns 503 for degraded state
- All services build successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-monitoring-alerting/05-02-SUMMARY.md`
</output>
