---
phase: 05-monitoring-alerting
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/shared/src/middleware/rate-limiter.ts
  - backend/auth-service/src/middleware/rate-limiter.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Auth rate limit hits are logged with warning level"
    - "Auth rate limit hits are sent to Sentry as warnings"
    - "Rate limit alerts include IP and path for investigation"
    - "Rate limit events are tagged as brute_force_attempt in Sentry"
  artifacts:
    - path: "backend/shared/src/middleware/rate-limiter.ts"
      provides: "Rate limiter with Sentry alerting"
      contains: "Sentry.captureMessage"
    - path: "backend/auth-service/src/middleware/rate-limiter.ts"
      provides: "Auth-specific rate limiter with alerting"
      contains: "brute_force"
  key_links:
    - from: "authLimiter"
      to: "Sentry.captureMessage"
      via: "handler callback"
      pattern: "handler.*Sentry"
---

<objective>
Add brute force detection alerting via rate limiter handler callback.

Purpose: Authentication attacks need real-time detection. When auth rate limits are hit, this indicates potential brute force attempts that should trigger alerts in Sentry for security monitoring and incident response.

Output: Rate limiter configuration with handler callback that logs rate limit hits and sends them to Sentry with appropriate tags for alerting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-monitoring-alerting/05-RESEARCH.md
@backend/shared/src/middleware/rate-limiter.ts - Current rate limiter implementation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alerting handler to authLimiter in shared package</name>
  <files>backend/shared/src/middleware/rate-limiter.ts</files>
  <action>
The shared rate-limiter.ts already exports `authLimiter`. Enhance it to include a handler callback that:
1. Logs the rate limit hit with warning level
2. Sends an alert to Sentry tagged as potential brute force attempt

**Current authLimiter:**
```typescript
export const authLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Too many authentication attempts, please try again after 15 minutes',
});
```

**Enhanced authLimiter:**

First, add the Sentry import at the top of the file:
```typescript
import * as Sentry from '@sentry/node';
```

Then add a logger import (or create inline console-based logging):
```typescript
// Simple logger for rate limiter (services can override with Winston)
const rateLimitLogger = {
  warn: (message: string, meta?: Record<string, unknown>) => {
    console.warn(JSON.stringify({ level: 'warn', message, ...meta, timestamp: new Date().toISOString() }));
  },
};
```

Then update authLimiter to use `rateLimit` directly with handler:
```typescript
/**
 * Auth rate limiter with brute force detection alerting (MON-03)
 * 5 attempts per 15 minutes - sends alerts to Sentry when triggered
 */
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,
  message: { success: false, error: 'Too many authentication attempts, please try again after 15 minutes' },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res, next, options) => {
    // Log rate limit hit for investigation
    rateLimitLogger.warn('Auth rate limit exceeded - potential brute force attempt', {
      ip: req.ip || req.socket?.remoteAddress || 'unknown',
      path: req.path,
      method: req.method,
      userAgent: req.headers['user-agent'],
      // Don't log user ID for auth endpoints (user may not be authenticated yet)
    });

    // Send to Sentry for alerting (MON-03)
    // Only capture if Sentry is initialized (SENTRY_DSN is set)
    if (process.env.SENTRY_DSN) {
      Sentry.captureMessage('Auth rate limit exceeded - potential brute force', {
        level: 'warning',
        tags: {
          type: 'brute_force_attempt',
          path: req.path,
        },
        extra: {
          ip: req.ip || req.socket?.remoteAddress || 'unknown',
          userAgent: req.headers['user-agent'],
          method: req.method,
        },
      });
    }

    // Send standard rate limit response
    res.status(options.statusCode).json(options.message);
  },
});
```

**Important:** Keep the existing `createRateLimiter` function and other rate limiters unchanged. Only enhance `authLimiter` since it's the one protecting authentication endpoints.
  </action>
  <verify>
1. `cd backend/shared && npm run build` compiles without errors
2. `grep -n "handler" src/middleware/rate-limiter.ts` shows handler callback
3. `grep -n "brute_force" src/middleware/rate-limiter.ts` shows Sentry tag
4. `grep -n "Sentry.captureMessage" src/middleware/rate-limiter.ts` shows alert
  </verify>
  <done>
authLimiter in shared package includes handler callback that logs and alerts on rate limit hits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify auth-service uses shared authLimiter correctly</name>
  <files>backend/auth-service/src/middleware/rate-limiter.ts, backend/auth-service/src/index.ts</files>
  <action>
Check if auth-service has its own rate-limiter.ts or imports from shared:

1. If auth-service has `src/middleware/rate-limiter.ts`:
   - Check if it re-exports from @vlvt/shared or defines its own limiters
   - If it defines its own authLimiter, update it to match the shared version with handler
   - Alternatively, replace with re-export: `export { authLimiter } from '@vlvt/shared';`

2. If auth-service imports directly from @vlvt/shared:
   - Verify the import path is correct
   - No changes needed

3. Check `src/index.ts` to see where authLimiter is applied:
   - It should be on `/auth/login`, `/auth/register`, `/auth/google`, `/auth/apple` endpoints
   - Verify it's being used (no need to add if already present)

**Likely scenarios:**
- auth-service may have a local rate-limiter.ts that imports and re-exports from shared
- Or it may import directly from @vlvt/shared in index.ts

Either way, once the shared authLimiter is updated, auth-service will get the new behavior.
  </action>
  <verify>
1. Check that auth-service applies authLimiter to auth endpoints
2. `cd backend/auth-service && npm run build` compiles
3. The rate limiter used on auth endpoints has the alerting handler
  </verify>
  <done>
Auth-service correctly uses the enhanced authLimiter from shared package on authentication endpoints.
  </done>
</task>

</tasks>

<verification>
1. `cd backend/shared && npm run build` - compiles
2. `cd backend/auth-service && npm run build` - compiles
3. authLimiter includes:
   - `handler` callback function
   - Logging with IP, path, userAgent
   - `Sentry.captureMessage` call
   - Tag `type: 'brute_force_attempt'`
4. Auth-service authentication routes are protected by authLimiter
</verification>

<success_criteria>
- authLimiter has handler callback for rate limit events
- Handler logs rate limit hits with warning level
- Handler sends events to Sentry with brute_force_attempt tag
- Auth-service auth endpoints use the enhanced limiter
- Shared package and auth-service build successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-monitoring-alerting/05-03-SUMMARY.md`
</output>
