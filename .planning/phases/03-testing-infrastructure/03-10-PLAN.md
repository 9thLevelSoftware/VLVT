---
phase: 03-testing-infrastructure
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/chat-service/tests/chat.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Chat service tests pass without 500 errors"
    - "Mock state preserved across tests"
  artifacts:
    - path: "backend/chat-service/tests/chat.test.ts"
      provides: "Fixed test setup with stable mocking"
  key_links:
    - from: "chat.test.ts"
      to: "src/index.ts"
      via: "single app import (no resetModules)"
      pattern: "import.*from.*index"
---

<objective>
Fix chat.test.ts failures caused by jest.resetModules() breaking mock state.

Purpose: Each test calls `jest.resetModules()` and re-imports the app, which invalidates mocks set up at the top of the file. This causes 500 errors when the real (unmocked) modules are used.

Output: chat.test.ts tests pass without 500 errors from mock infrastructure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-testing-infrastructure/03-VERIFICATION.md

@backend/chat-service/tests/chat.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove jest.resetModules and use single app import</name>
  <files>backend/chat-service/tests/chat.test.ts</files>
  <action>
Refactor chat.test.ts to NOT use jest.resetModules():

1. Remove from beforeEach:
   ```typescript
   // DELETE THESE LINES
   jest.resetModules();
   delete require.cache[require.resolve('../src/index')];
   ```

2. Import app ONCE at module level (after mocks):
   ```typescript
   // At top, AFTER jest.mock() calls
   import request from 'supertest';
   import { Pool } from 'pg';
   import app from '../src/index';  // Single import, keeps mock bindings
   ```

3. Remove dynamic require from each test:
   ```typescript
   // DELETE FROM EACH TEST:
   const appModule = require('../src/index');
   app = appModule.default || appModule;
   ```

4. Keep `jest.clearAllMocks()` in beforeEach to reset mock call counts.

5. The `let app: any;` at describe level becomes unnecessary - use imported app directly.

Why this works: jest.mock() hoists to the top and intercepts require/import. When we import app after mocks are set up, the app uses mocked dependencies. resetModules breaks this by clearing the mock registry.
  </action>
  <verify>
```bash
cd backend/chat-service && npm test -- --testPathPattern=chat.test.ts --testNamePattern="Health" --verbose
```
Health check should pass without 500 error.
  </verify>
  <done>App imported once, no resetModules, health check passes</done>
</task>

<task type="auto">
  <name>Task 2: Add missing mocks for CSRF and @vlvt/shared</name>
  <files>backend/chat-service/tests/chat.test.ts</files>
  <action>
The chat-service likely uses @vlvt/shared for CSRF middleware. Add mock at top:

```typescript
// Add with other jest.mock() calls at the top
jest.mock('@vlvt/shared', () => ({
  createCsrfMiddleware: jest.fn(() => (req: any, res: any, next: any) => next()),
  createCsrfTokenHandler: jest.fn(() => (req: any, res: any) => res.json({ token: 'mock-token' })),
  createAuditLogger: jest.fn(() => ({
    logAction: jest.fn().mockResolvedValue(undefined),
    logAuthEvent: jest.fn().mockResolvedValue(undefined),
    logDataChange: jest.fn().mockResolvedValue(undefined),
  })),
  AuditAction: {},
  AuditResourceType: {},
  addVersionToHealth: jest.fn((obj: any) => obj),
  createVersionMiddleware: jest.fn(() => (req: any, res: any, next: any) => next()),
  API_VERSIONS: { V1: 'v1' },
  CURRENT_API_VERSION: 'v1',
  ErrorCodes: {},
  sendErrorResponse: jest.fn(),
  createErrorResponseSender: jest.fn(() => jest.fn()),
}));
```

Also mock rate-limiter if chat-service uses it:
```typescript
jest.mock('../src/middleware/rate-limiter', () => ({
  chatLimiter: (req: any, res: any, next: any) => next(),
  generalLimiter: (req: any, res: any, next: any) => next(),
}));
```

Check what the chat-service imports and ensure all external dependencies that cause side effects are mocked.
  </action>
  <verify>
```bash
cd backend/chat-service && npm test -- --testPathPattern=chat.test.ts --verbose 2>&1 | head -100
```
Check for import errors or missing mock warnings.
  </verify>
  <done>All required mocks in place, no import errors</done>
</task>

<task type="auto">
  <name>Task 3: Verify full test suite passes</name>
  <files>backend/chat-service/tests/chat.test.ts</files>
  <action>
Run full chat.test.ts suite and fix any remaining issues:

1. If tests still get 500 errors, check which endpoint fails and trace:
   - What query/mock sequence does the endpoint expect?
   - Is the mock returning correct structure?

2. Common fixes needed:
   - Mock pool.query may need more specific mock sequences for certain tests
   - Some tests may need mockPool.query.mockReset() before setting up specific sequence

3. For any remaining 403/401 issues, verify:
   - JWT token is properly signed with JWT_SECRET
   - Token contains expected userId that matches test assertions
  </action>
  <verify>
```bash
cd backend/chat-service && npm test -- --testPathPattern=chat.test.ts --verbose
```
  </verify>
  <done>chat.test.ts: all tests pass or have clear skip reasons</done>
</task>

</tasks>

<verification>
```bash
cd backend/chat-service && npm test -- --testPathPattern=chat.test.ts --verbose
```
Expected: Tests pass without 500 Internal Server Errors from mock infrastructure
</verification>

<success_criteria>
- [ ] No jest.resetModules() in chat.test.ts
- [ ] App imported once at module level
- [ ] @vlvt/shared mock in place
- [ ] Tests don't fail with 500 errors
- [ ] Match, message, block, report endpoints all tested
</success_criteria>

<output>
After completion, create `.planning/phases/03-testing-infrastructure/03-10-SUMMARY.md`
</output>
