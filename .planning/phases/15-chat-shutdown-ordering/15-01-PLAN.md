---
phase: 15-chat-shutdown-ordering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/chat-service/src/index.ts
autonomous: true
requirements: [RESIL-06]
gap_closure: true

must_haves:
  truths:
    - "Chat-service awaits io.close() completion before calling pool.end()"
    - "In-flight Socket.IO connections and HTTP requests complete before the database pool is closed during shutdown"
    - "io.close() errors are caught and logged without preventing pool.end() cleanup"
    - "The same Promise-wrapping pattern from Phase 12 (auth/profile) is applied consistently"
  artifacts:
    - path: "backend/chat-service/src/index.ts"
      provides: "Promise-wrapped io.close() in gracefulShutdown"
      contains: "await new Promise"
  key_links:
    - from: "gracefulShutdown()"
      to: "io.close()"
      via: "await new Promise wrapper"
      pattern: "await new Promise.*io\\.close"
    - from: "io.close() completion"
      to: "pool.end()"
      via: "sequential await (io closes before pool)"
      pattern: "resolve\\(\\).*\\}.*\\}\\).*pool\\.end"
---

<objective>
Wrap io.close() in a Promise and await it in chat-service graceful shutdown, so Socket.IO client disconnections AND the underlying HTTP server finish draining all in-flight requests before pool.end() closes the database pool.

Purpose: Prevent 500 errors on in-flight REST requests (matches, messages, blocks, reports, dates, FCM endpoints) during Railway redeploys. Currently io.close() is fire-and-forget (callback-style, returns immediately), so pool.end() races with in-flight HTTP requests that still need database access. This is the same bug Phase 12 fixed in auth-service and profile-service, now applied to chat-service.

Output: One modified index.ts file with Promise-wrapped io.close() in the gracefulShutdown function.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-chat-shutdown-ordering/15-RESEARCH.md

Key prior work: Phase 09 (plan 09-02) created the chat-service gracefulShutdown handler. Phase 12 (plan 12-01) established the Promise wrapper pattern for server.close() in auth-service and profile-service.

<interfaces>
<!-- Current shutdown code in chat-service — this is the exact code to modify: -->

From backend/chat-service/src/index.ts (lines 1643-1689):
```typescript
const gracefulShutdown = async (signal: string) => {
  if (isShuttingDown) {
    logger.warn(`Duplicate ${signal} received, shutdown already in progress`);
    return;
  }
  isShuttingDown = true;
  logger.info(`Received ${signal}, starting graceful shutdown...`);

  // Force exit after 10 seconds to prevent hung deployments
  const forceExitTimer = setTimeout(() => {
    logger.error('Graceful shutdown timed out after 10s, forcing exit');
    process.exit(1);
  }, 10000);
  forceExitTimer.unref();

  // Close message cleanup job
  await closeMessageCleanupJob().catch((err) => {
    logger.error('Error closing message cleanup job', { error: err.message });
  });

  // Close Redis subscriber for After Hours events
  await closeAfterHoursRedisSubscriber().catch((err) => {
    logger.error('Error closing After Hours Redis subscriber', { error: err.message });
  });

  // BUG: fire-and-forget, returns immediately
  io.close(() => {
    logger.info('Socket.IO server closed');
  });

  // BUG: races with in-flight HTTP/WebSocket requests
  try {
    await pool.end();
    logger.info('Database pool closed');
  } catch (err) {
    logger.error('Error closing database pool', { error: (err as Error).message });
  }

  process.exit(0);
};
```

<!-- Phase 12 established pattern (from auth-service, for reference): -->
```typescript
// Stop accepting new HTTP requests, wait for in-flight to complete
try {
  await new Promise<void>((resolve, reject) => {
    server.close((err) => {
      if (err) {
        logger.error('Error closing HTTP server', { error: (err as Error).message });
        reject(err);
      } else {
        logger.info('HTTP server closed');
        resolve();
      }
    });
  });
} catch {
  // server.close error logged above; continue with pool cleanup
}
```

<!-- IMPORTANT: io.close() in Socket.IO 4.8.1 is async but its returned Promise
resolves BEFORE the underlying HTTP server finishes draining. The callback `fn`
is forwarded to httpServer.close(fn) and fires when the HTTP server fully closes.
Do NOT rely on `await io.close()` alone — use the callback wrapper. -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap io.close() in Promise in chat-service gracefulShutdown</name>
  <files>backend/chat-service/src/index.ts</files>
  <action>
In backend/chat-service/src/index.ts, replace the fire-and-forget io.close() block (lines ~1671-1674) with a Promise-wrapped, awaited version.

**Replace this** (lines 1671-1674):
```typescript
    // Close Socket.IO (disconnects all clients AND closes underlying HTTP server)
    io.close(() => {
      logger.info('Socket.IO server closed');
    });
```

**With this:**
```typescript
    // Close Socket.IO (disconnects all clients AND closes underlying HTTP server)
    // NOTE: io.close() is async but its returned Promise resolves before the
    // underlying HTTP server finishes draining. The callback is forwarded to
    // httpServer.close() and fires when the HTTP server fully closes.
    try {
      await new Promise<void>((resolve, reject) => {
        io.close((err) => {
          if (err) {
            logger.error('Error closing Socket.IO server', { error: (err as Error).message });
            reject(err);
          } else {
            logger.info('Socket.IO server closed');
            resolve();
          }
        });
      });
    } catch {
      // io.close error logged above; continue with pool cleanup
    }
```

**What NOT to change:**
- Do NOT modify the guard flag (isShuttingDown), force-exit timer, or process.exit(0) sections
- Do NOT modify the closeMessageCleanupJob() or closeAfterHoursRedisSubscriber() calls — they must remain BEFORE io.close() because they may need database access
- Do NOT move pool.end() into the io.close callback (loses try/catch structure and breaks Phase 12 consistency)
- Do NOT remove the 10s force-exit timer (it handles keep-alive hangs)
- Do NOT use `await io.close()` without the callback wrapper — the returned Promise resolves before the HTTP server finishes draining (see research)
- Do NOT use util.promisify — manual wrapper is clearer about error handling and consistent with Phase 12 pattern

**Why the empty catch block:** If io.close() errors (e.g., server not listening), we still want pool.end() to run for cleanup. The error is already logged inside the Promise. The catch block prevents the rejection from skipping pool.end().

**Shutdown order after the fix (verify this is preserved):**
1. Guard flag (isShuttingDown) — prevent double shutdown
2. Force-exit timer (10s, .unref()) — safety net
3. closeMessageCleanupJob() — stop background job (may need DB)
4. closeAfterHoursRedisSubscriber() — stop Redis subscriber
5. io.close() via Promise wrapper — disconnect sockets + drain HTTP (AWAITED)
6. pool.end() — close DB pool (safe now, all requests finished)
7. process.exit(0) — clean exit
  </action>
  <verify>
    <automated>cd "C:/Users/dasbl/AndroidStudioProjects/VLVT/backend/chat-service" && npm test 2>&1 | tail -20</automated>
    Verify: grep for "await new Promise" in the gracefulShutdown function. The fire-and-forget pattern `io.close(() =>` without a surrounding `new Promise` should no longer exist. Instead, `await new Promise<void>((resolve, reject) => { io.close((err) =>` should be present.
    Also verify: `pool.end()` still appears AFTER the Promise block, not inside it.
    Also verify: closeMessageCleanupJob() and closeAfterHoursRedisSubscriber() remain BEFORE io.close().
  </verify>
  <done>
    - io.close() is wrapped in `await new Promise<void>()` in chat-service gracefulShutdown
    - Error parameter from io.close callback is checked and logged
    - Rejection is caught so pool.end() still runs on io.close failure
    - pool.end() remains sequential after io.close completion
    - Shutdown ordering preserved: guard -> timer -> cleanup job -> Redis -> io.close (awaited) -> pool.end -> exit
    - All chat-service tests still pass
  </done>
</task>

</tasks>

<verification>
After the task completes, verify the fix holistically:

1. **Pattern check:**
   ```bash
   grep -n "await new Promise" backend/chat-service/src/index.ts
   ```
   Expected: Contains `await new Promise<void>` in the gracefulShutdown function.

2. **Anti-pattern check:**
   ```bash
   grep -n "io.close(() =>" backend/chat-service/src/index.ts
   ```
   Expected: NO matches for fire-and-forget `io.close(() =>`. The only `io.close` call should be inside the `new Promise` wrapper.

3. **Ordering check:**
   ```bash
   grep -n "closeMessageCleanupJob\|closeAfterHoursRedisSubscriber\|io.close\|pool.end\|process.exit" backend/chat-service/src/index.ts | tail -10
   ```
   Expected: Line numbers in order: cleanupJob < redisSubscriber < io.close < pool.end < process.exit.

4. **Consistency check (all three services now use Promise wrapper):**
   ```bash
   grep -c "await new Promise" backend/auth-service/src/index.ts backend/profile-service/src/index.ts backend/chat-service/src/index.ts
   ```
   Expected: All three files contain at least 1 `await new Promise` in their shutdown handlers.

5. **Test suite:**
   ```bash
   cd backend/chat-service && npm test
   ```
   Expected: All tests pass.
</verification>

<success_criteria>
1. Chat-service gracefulShutdown awaits io.close() via Promise wrapper before calling pool.end()
2. io.close() error is caught, logged, and does not prevent pool.end() cleanup
3. Shutdown ordering preserved: cleanup job -> Redis subscriber -> io.close (awaited) -> pool.end -> exit
4. All three backend services (auth, profile, chat) now consistently use Promise-wrapped close() in their shutdown handlers
5. No test regressions — all chat-service tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-chat-shutdown-ordering/15-01-SUMMARY.md`
</output>
