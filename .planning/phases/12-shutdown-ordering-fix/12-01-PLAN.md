---
phase: 12-shutdown-ordering-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/auth-service/src/index.ts
  - backend/profile-service/src/index.ts
autonomous: true
requirements: [RESIL-04, RESIL-05]
gap_closure: true

must_haves:
  truths:
    - "Auth-service awaits server.close() completion before calling pool.end()"
    - "Profile-service awaits server.close() completion before calling pool.end()"
    - "In-flight HTTP requests complete before the database pool is torn down during shutdown"
    - "server.close() errors are caught and logged without preventing pool.end() cleanup"
  artifacts:
    - path: "backend/auth-service/src/index.ts"
      provides: "Promise-wrapped server.close() in gracefulShutdown"
      contains: "await new Promise"
    - path: "backend/profile-service/src/index.ts"
      provides: "Promise-wrapped server.close() in gracefulShutdown"
      contains: "await new Promise"
  key_links:
    - from: "gracefulShutdown()"
      to: "server.close()"
      via: "await new Promise wrapper"
      pattern: "await new Promise.*server\\.close"
    - from: "server.close() completion"
      to: "pool.end()"
      via: "sequential await (server closes before pool)"
      pattern: "resolve\\(\\).*\\}.*\\}\\).*pool\\.end"
---

<objective>
Wrap server.close() in a Promise and await it in both auth-service and profile-service graceful shutdown handlers, so the HTTP server finishes draining all in-flight requests before pool.end() closes the database pool.

Purpose: Prevent 500 errors on in-flight requests during Railway redeploys. Currently server.close() is fire-and-forget (callback-style, returns immediately), so pool.end() races with in-flight requests that may still need database access.

Output: Two modified index.ts files with Promise-wrapped server.close() in their gracefulShutdown functions.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-shutdown-ordering-fix/12-RESEARCH.md

Key prior work: Phase 09 (plans 09-01 and 09-02) implemented these shutdown handlers.

<interfaces>
<!-- Current shutdown code in both services follows this exact pattern: -->

From backend/auth-service/src/index.ts (lines 3656-3685):
```typescript
const gracefulShutdown = async (signal: string) => {
  if (isShuttingDown) {
    logger.warn(`Duplicate ${signal} received, shutdown already in progress`);
    return;
  }
  isShuttingDown = true;
  logger.info(`Received ${signal}, starting graceful shutdown...`);

  const forceExitTimer = setTimeout(() => {
    logger.error('Graceful shutdown timed out after 10s, forcing exit');
    process.exit(1);
  }, 10000);
  forceExitTimer.unref();

  // BUG: fire-and-forget, returns immediately
  server.close(() => {
    logger.info('HTTP server closed');
  });

  // BUG: races with in-flight requests
  try {
    await pool.end();
    logger.info('Database pool closed');
  } catch (err) {
    logger.error('Error closing database pool', { error: (err as Error).message });
  }

  process.exit(0);
};
```

From backend/profile-service/src/index.ts (lines 1823-1863):
```typescript
// Same pattern as auth-service, but with scheduler cleanup between server.close and pool.end:
server.close(() => {          // BUG: fire-and-forget
  logger.info('HTTP server closed');
});

// These scheduler closures are CORRECT and stay between server.close and pool.end
await closeMatchingScheduler().catch(...);
await closeSessionScheduler().catch(...);
await closeSessionCleanupJob().catch(...);

// BUG: races with in-flight requests
try {
  await pool.end();
  ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap server.close() in Promise in auth-service gracefulShutdown</name>
  <files>backend/auth-service/src/index.ts</files>
  <action>
In backend/auth-service/src/index.ts, replace the fire-and-forget server.close() block (lines ~3671-3674) with a Promise-wrapped, awaited version:

**Replace this** (lines 3671-3674):
```typescript
// Stop accepting new HTTP requests, drain in-flight
server.close(() => {
  logger.info('HTTP server closed');
});
```

**With this:**
```typescript
// Stop accepting new HTTP requests, wait for in-flight to complete
try {
  await new Promise<void>((resolve, reject) => {
    server.close((err) => {
      if (err) {
        logger.error('Error closing HTTP server', { error: (err as Error).message });
        reject(err);
      } else {
        logger.info('HTTP server closed');
        resolve();
      }
    });
  });
} catch {
  // server.close error logged above; continue with pool cleanup
}
```

**What NOT to change:**
- Do NOT modify the guard flag, force-exit timer, pool.end(), or process.exit(0) sections
- Do NOT move pool.end() into the server.close callback (loses try/catch structure)
- Do NOT remove the 10s force-exit timer (it handles keep-alive hangs)
- Do NOT use util.promisify (manual wrapper is clearer about error handling)

**Why the empty catch block:** If server.close() errors (e.g., server not listening), we still want pool.end() to run for cleanup. The error is already logged inside the Promise. The catch block prevents the rejection from skipping pool.end().
  </action>
  <verify>
    <automated>cd backend/auth-service && npm test 2>&1 | tail -20</automated>
    Verify: grep for "await new Promise" in the gracefulShutdown function. The pattern `server.close(() =>` (fire-and-forget) should no longer exist. Instead, `await new Promise<void>((resolve, reject) => { server.close((err) =>` should be present.
    Also verify: `pool.end()` still appears AFTER the Promise block, not inside it.
  </verify>
  <done>
    - server.close() is wrapped in `await new Promise<void>()` in auth-service gracefulShutdown
    - Error parameter from server.close callback is checked and logged
    - Rejection is caught so pool.end() still runs on server.close failure
    - pool.end() remains sequential after server.close completion
    - All auth-service tests that were passing before still pass (12 pre-existing failures in account-lockout.test.ts are expected)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap server.close() in Promise in profile-service gracefulShutdown</name>
  <files>backend/profile-service/src/index.ts</files>
  <action>
In backend/profile-service/src/index.ts, replace the fire-and-forget server.close() block (lines ~1838-1841) with the identical Promise-wrapped pattern:

**Replace this** (lines 1838-1841):
```typescript
// Stop accepting new HTTP requests
server.close(() => {
  logger.info('HTTP server closed');
});
```

**With this:**
```typescript
// Stop accepting new HTTP requests, wait for in-flight to complete
try {
  await new Promise<void>((resolve, reject) => {
    server.close((err) => {
      if (err) {
        logger.error('Error closing HTTP server', { error: (err as Error).message });
        reject(err);
      } else {
        logger.info('HTTP server closed');
        resolve();
      }
    });
  });
} catch {
  // server.close error logged above; continue with cleanup
}
```

**What NOT to change:**
- Do NOT modify the scheduler cleanup calls (closeMatchingScheduler, closeSessionScheduler, closeSessionCleanupJob) -- they remain AFTER server.close and BEFORE pool.end, which is correct because schedulers may need DB access
- Do NOT modify the guard flag, force-exit timer, pool.end(), or process.exit(0) sections
- The shutdown order after this fix is: server.close (awaited) -> schedulers -> pool.end -> exit

**Verify the ordering after the change:**
1. `await new Promise(server.close)` -- blocks until HTTP drain
2. `await closeMatchingScheduler().catch(...)` -- scheduler cleanup
3. `await closeSessionScheduler().catch(...)` -- scheduler cleanup
4. `await closeSessionCleanupJob().catch(...)` -- scheduler cleanup
5. `await pool.end()` -- database pool closed
6. `process.exit(0)` -- clean exit
  </action>
  <verify>
    <automated>cd backend/profile-service && npm test 2>&1 | tail -20</automated>
    Verify: grep for "await new Promise" in the gracefulShutdown function. The pattern `server.close(() =>` (fire-and-forget) should no longer exist.
    Also verify: scheduler cleanup calls remain between server.close and pool.end.
    Also verify: 10 pre-existing failures in search-filters.test.ts are expected and unchanged.
  </verify>
  <done>
    - server.close() is wrapped in `await new Promise<void>()` in profile-service gracefulShutdown
    - Error parameter from server.close callback is checked and logged
    - Rejection is caught so scheduler cleanup + pool.end() still run on server.close failure
    - Shutdown ordering preserved: server.close -> schedulers -> pool.end -> exit
    - All profile-service tests that were passing before still pass (10 pre-existing failures in search-filters.test.ts are expected)
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the fix holistically:

1. **Pattern check (both files):**
   ```bash
   grep -n "await new Promise" backend/auth-service/src/index.ts backend/profile-service/src/index.ts
   ```
   Expected: Both files contain `await new Promise<void>` in their gracefulShutdown functions.

2. **Anti-pattern check (both files):**
   ```bash
   grep -n "server.close(() =>" backend/auth-service/src/index.ts backend/profile-service/src/index.ts
   ```
   Expected: NO matches. The fire-and-forget pattern should be gone from both files.

3. **Ordering check (profile-service):**
   ```bash
   grep -n "server.close\|closeMatchingScheduler\|closeSessionScheduler\|closeSessionCleanupJob\|pool.end\|process.exit" backend/profile-service/src/index.ts | tail -10
   ```
   Expected: server.close line number < scheduler line numbers < pool.end line number < process.exit line number.

4. **Test suites:**
   ```bash
   cd backend/auth-service && npm test
   cd backend/profile-service && npm test
   ```
   Expected: Same pass/fail counts as before the change. Pre-existing failures unchanged.

5. **TypeScript compilation:**
   ```bash
   cd backend/auth-service && npx tsc --noEmit
   cd backend/profile-service && npx tsc --noEmit
   ```
   Expected: No new TypeScript errors.
</verification>

<success_criteria>
1. Auth-service gracefulShutdown awaits server.close() via Promise wrapper before calling pool.end()
2. Profile-service gracefulShutdown awaits server.close() via Promise wrapper before calling pool.end()
3. Profile-service scheduler cleanup remains between server.close and pool.end (ordering preserved)
4. server.close() error is caught, logged, and does not prevent pool.end() cleanup
5. No test regressions -- same pass/fail counts as before the change
6. No TypeScript compilation errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/12-shutdown-ordering-fix/12-01-SUMMARY.md`
</output>
