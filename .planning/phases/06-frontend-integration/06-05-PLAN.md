---
phase: 06-frontend-integration
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03", "06-04"]
files_modified:
  - frontend/lib/screens/after_hours_chat_screen.dart
  - frontend/lib/screens/after_hours_tab_screen.dart
  - frontend/pubspec.yaml
  - frontend/android/app/src/main/AndroidManifest.xml
autonomous: true

must_haves:
  truths:
    - "User can chat in real-time during After Hours session"
    - "Session timer visible above chat"
    - "Save button visible above message input"
    - "Partner saved notification triggers save button state change"
    - "Session expiry closes chat and navigates back"
  artifacts:
    - path: "frontend/lib/screens/after_hours_chat_screen.dart"
      provides: "Ephemeral chat UI with timer and save button"
      contains: "AfterHoursChatScreen"
      min_lines: 300
    - path: "frontend/pubspec.yaml"
      provides: "flutter_foreground_task dependency"
      contains: "flutter_foreground_task"
  key_links:
    - from: "frontend/lib/screens/after_hours_chat_screen.dart"
      to: "after_hours_chat_service.dart"
      via: "message sending and history"
      pattern: "context\\.read<AfterHoursChatService>"
    - from: "frontend/lib/screens/after_hours_chat_screen.dart"
      to: "socket_service.dart"
      via: "real-time message events"
      pattern: "onAfterHoursMessage"
    - from: "frontend/lib/screens/after_hours_chat_screen.dart"
      to: "save_match_button.dart"
      via: "save button widget"
      pattern: "SaveMatchButton"
---

<objective>
Create the ephemeral After Hours chat screen with session timer, save button, and background location support.

Purpose: Users need to chat in real-time during their After Hours session with clear indicators of time remaining and the ability to save the match.

Output: Complete chat screen forked from existing chat_screen.dart, with After Hours specific features (timer, save, expiry handling).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-frontend-integration/06-CONTEXT.md
@.planning/phases/06-frontend-integration/06-RESEARCH.md

Reference prior plan summaries (if available):
@.planning/phases/06-frontend-integration/06-01-SUMMARY.md
@.planning/phases/06-frontend-integration/06-02-SUMMARY.md
@.planning/phases/06-frontend-integration/06-03-SUMMARY.md
@.planning/phases/06-frontend-integration/06-04-SUMMARY.md

Reference existing patterns:
@frontend/lib/screens/chat_screen.dart (messaging patterns)
@frontend/lib/services/after_hours_chat_service.dart (saveMatch, getMessageHistory)
@frontend/lib/services/socket_service.dart (After Hours message events)
@frontend/lib/widgets/save_match_button.dart (save button widget)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flutter_foreground_task dependency and Android config</name>
  <files>frontend/pubspec.yaml, frontend/android/app/src/main/AndroidManifest.xml</files>
  <action>
1. Add flutter_foreground_task to pubspec.yaml dependencies:
   ```yaml
   dependencies:
     # ... existing deps ...
     flutter_foreground_task: ^9.2.0
   ```

   Run: `cd frontend && flutter pub get`

2. Update AndroidManifest.xml (frontend/android/app/src/main/AndroidManifest.xml):

   Add permissions (before `<application>` tag):
   ```xml
   <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
   <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
   ```

   Add service declaration (inside `<application>` tag, after existing services):
   ```xml
   <service
       android:name="com.pravera.flutter_foreground_task.service.ForegroundService"
       android:foregroundServiceType="location"
       android:exported="false" />
   ```

Note: iOS configuration is optional for v1 - background location on iOS has different requirements and may need push notification workaround. Document this as known limitation for now.
  </action>
  <verify>
    - `cd frontend && flutter pub get` succeeds
    - `flutter analyze` shows no errors
    - AndroidManifest.xml has foreground service permissions and declaration
  </verify>
  <done>flutter_foreground_task added to project with Android manifest configuration</done>
</task>

<task type="auto">
  <name>Task 2: Create After Hours chat screen</name>
  <files>frontend/lib/screens/after_hours_chat_screen.dart</files>
  <action>
Create AfterHoursChatScreen by forking chat_screen.dart and adapting for After Hours.

**Note on SocketService methods:** The following methods already exist in socket_service.dart (created in Phase 4):
- `joinAfterHoursChat(matchId)` - joins the socket room for a match
- `leaveAfterHoursChat(matchId)` - leaves the socket room
- `sendAfterHoursTypingIndicator(matchId, isTyping)` - sends typing indicator
- `markAfterHoursMessagesRead(matchId)` - marks messages as read

These are NOT new methods - they were added in Phase 4 for Socket.IO integration. This task uses them.

```dart
/// After Hours Chat Screen
/// Ephemeral chat UI with session timer and save button
library;

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../services/auth_service.dart';
import '../services/after_hours_service.dart';
import '../services/after_hours_chat_service.dart';
import '../services/socket_service.dart';
import '../models/message.dart';
import '../utils/date_utils.dart';
import '../widgets/after_hours/session_timer.dart';
import '../widgets/after_hours/session_expiry_banner.dart';
import '../widgets/save_match_button.dart';
import '../widgets/vlvt_input.dart';
import '../widgets/vlvt_loader.dart';
import '../theme/vlvt_colors.dart';
import '../theme/vlvt_text_styles.dart';

class AfterHoursChatScreen extends StatefulWidget {
  final AfterHoursMatch match;

  const AfterHoursChatScreen({
    super.key,
    required this.match,
  });

  @override
  State<AfterHoursChatScreen> createState() => _AfterHoursChatScreenState();
}

class _AfterHoursChatScreenState extends State<AfterHoursChatScreen>
    with WidgetsBindingObserver {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  // State
  List<Message> _messages = [];
  bool _isLoading = true;
  bool _isSending = false;
  bool _otherUserTyping = false;
  SaveButtonState _saveState = SaveButtonState.notSaved;

  // Socket subscriptions
  StreamSubscription<Message>? _messageSubscription;
  StreamSubscription<Map<String, dynamic>>? _typingSubscription;
  StreamSubscription<Map<String, dynamic>>? _readSubscription;
  StreamSubscription<Map<String, dynamic>>? _partnerSavedSubscription;
  StreamSubscription<Map<String, dynamic>>? _matchSavedSubscription;
  StreamSubscription<Map<String, dynamic>>? _sessionExpiredSubscription;

  // Typing
  Timer? _typingTimer;
  bool _isTyping = false;

  static const int _maxCharacters = 500;
  static const Duration _typingTimeout = Duration(seconds: 2);

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _loadMessages();
    _setupSocketListeners();
    _messageController.addListener(_onTextChanged);

    // Join the chat room (method exists in socket_service.dart from Phase 4)
    final socketService = context.read<SocketService>();
    socketService.joinAfterHoursChat(widget.match.id);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cancelSocketListeners();
    _typingTimer?.cancel();
    _messageController.removeListener(_onTextChanged);
    _messageController.dispose();
    _scrollController.dispose();

    // Leave the chat room (method exists in socket_service.dart from Phase 4)
    try {
      final socketService = context.read<SocketService>();
      socketService.leaveAfterHoursChat(widget.match.id);
    } catch (_) {}

    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // Refresh messages and check session status
      _loadMessages();
      context.read<AfterHoursService>().refreshSessionStatus();
    }
  }

  void _setupSocketListeners() {
    final socketService = context.read<SocketService>();

    _messageSubscription = socketService.onAfterHoursMessage.listen((message) {
      if (!mounted || message.matchId != widget.match.id) return;
      final wasNearBottom = _isNearBottom();
      setState(() {
        _messages = [..._messages, message];
      });
      if (wasNearBottom) {
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom(animated: true));
      }
      _markMessagesAsRead();
    });

    _typingSubscription = socketService.onAfterHoursTyping.listen((data) {
      if (!mounted || data['matchId'] != widget.match.id) return;
      final userId = data['userId'] as String?;
      if (userId == context.read<AuthService>().userId) return;
      final isTyping = data['isTyping'] as bool? ?? false;
      setState(() => _otherUserTyping = isTyping);
    });

    _readSubscription = socketService.onAfterHoursMessagesRead.listen((data) {
      if (!mounted || data['matchId'] != widget.match.id) return;
      // Update message status to read
      final messageIds = (data['messageIds'] as List?)?.cast<String>() ?? [];
      setState(() {
        _messages = _messages.map((m) {
          return messageIds.contains(m.id)
              ? m.copyWith(status: MessageStatus.read)
              : m;
        }).toList();
      });
    });

    _partnerSavedSubscription = socketService.onPartnerSaved.listen((data) {
      if (!mounted || data['matchId'] != widget.match.id) return;
      setState(() {
        if (_saveState == SaveButtonState.notSaved) {
          _saveState = SaveButtonState.partnerSavedFirst;
        }
      });
      // Show alert
      _showPartnerSavedAlert();
    });

    _matchSavedSubscription = socketService.onMatchSaved.listen((data) {
      if (!mounted || data['matchId'] != widget.match.id) return;
      setState(() {
        _saveState = SaveButtonState.mutualSaved;
      });
      // Show celebration and navigate to regular matches
      _showMutualSaveSuccess(data['permanentMatchId'] as String?);
    });

    _sessionExpiredSubscription = socketService.onSessionExpired.listen((data) {
      if (!mounted) return;
      // Session ended - close chat
      _handleSessionExpired();
    });
  }

  void _cancelSocketListeners() {
    _messageSubscription?.cancel();
    _typingSubscription?.cancel();
    _readSubscription?.cancel();
    _partnerSavedSubscription?.cancel();
    _matchSavedSubscription?.cancel();
    _sessionExpiredSubscription?.cancel();
  }

  Future<void> _loadMessages() async {
    final chatService = context.read<AfterHoursChatService>();
    try {
      final messages = await chatService.getMessageHistory(matchId: widget.match.id);
      if (mounted) {
        setState(() {
          _messages = messages;
          _isLoading = false;
        });
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
        _markMessagesAsRead();
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  void _onTextChanged() {
    final socketService = context.read<SocketService>();
    if (_messageController.text.trim().isNotEmpty && !_isTyping) {
      setState(() => _isTyping = true);
      // Method exists in socket_service.dart from Phase 4
      socketService.sendAfterHoursTypingIndicator(
        matchId: widget.match.id,
        isTyping: true,
      );
    }
    _typingTimer?.cancel();
    _typingTimer = Timer(_typingTimeout, () {
      if (mounted) {
        setState(() => _isTyping = false);
        socketService.sendAfterHoursTypingIndicator(
          matchId: widget.match.id,
          isTyping: false,
        );
      }
    });
  }

  Future<void> _sendMessage() async {
    final text = _messageController.text.trim();
    if (text.isEmpty || text.length > _maxCharacters || _isSending) return;

    setState(() => _isSending = true);

    final authService = context.read<AuthService>();
    final chatService = context.read<AfterHoursChatService>();
    final currentUserId = authService.userId;

    if (currentUserId == null) {
      setState(() => _isSending = false);
      return;
    }

    final tempId = 'temp_${DateTime.now().millisecondsSinceEpoch}';

    // Optimistic update
    final tempMessage = Message(
      id: tempId,
      matchId: widget.match.id,
      senderId: currentUserId,
      text: text,
      timestamp: DateTime.now(),
      status: MessageStatus.sending,
    );

    setState(() {
      _messages = [..._messages, tempMessage];
      _messageController.clear();
    });
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom(animated: true));

    try {
      final sentMessage = await chatService.sendMessageWithRetry(
        matchId: widget.match.id,
        text: text,
        tempId: tempId,
      );

      if (mounted) {
        if (sentMessage != null) {
          setState(() {
            _isSending = false;
            _messages = _messages.where((m) => m.id != tempId).toList()..add(sentMessage);
          });
        } else {
          setState(() {
            _isSending = false;
            _messages = _messages.map((m) => m.id == tempId
                ? m.copyWith(status: MessageStatus.failed)
                : m).toList();
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isSending = false;
          _messages = _messages.map((m) => m.id == tempId
              ? m.copyWith(status: MessageStatus.failed, error: e.toString())
              : m).toList();
        });
      }
    }
  }

  Future<void> _saveMatch() async {
    setState(() => _saveState = SaveButtonState.saving);

    final chatService = context.read<AfterHoursChatService>();
    final result = await chatService.saveMatch(matchId: widget.match.id);

    if (mounted) {
      if (result.success) {
        if (result.mutualSave) {
          setState(() => _saveState = SaveButtonState.mutualSaved);
          _showMutualSaveSuccess(result.permanentMatchId);
        } else {
          setState(() => _saveState = SaveButtonState.waitingForPartner);
        }
      } else {
        setState(() => _saveState = SaveButtonState.notSaved);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error ?? 'Failed to save match'),
            backgroundColor: VlvtColors.error,
          ),
        );
      }
    }
  }

  void _showPartnerSavedAlert() {
    HapticFeedback.heavyImpact();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.favorite, color: VlvtColors.crimson),
            const SizedBox(width: 8),
            const Text('They saved!'),
          ],
        ),
        content: Text(
          '${widget.match.name} wants to keep chatting! Save back to make this a permanent match.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Later'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _saveMatch();
            },
            child: Text('Save Now', style: TextStyle(color: VlvtColors.gold)),
          ),
        ],
      ),
    );
  }

  void _showMutualSaveSuccess(String? permanentMatchId) {
    HapticFeedback.heavyImpact();
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.celebration, color: VlvtColors.gold),
            const SizedBox(width: 8),
            const Text('Match Saved!'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'You and ${widget.match.name} are now a permanent match!',
            ),
            const SizedBox(height: 8),
            Text(
              'Your chat history has been saved. You can find them in your regular matches.',
              style: VlvtTextStyles.bodySmall.copyWith(color: VlvtColors.textSecondary),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context); // Close dialog
              Navigator.pop(context); // Close chat
              // Navigate to matches (handled by main screen)
            },
            child: const Text('View Matches'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Keep Chatting'),
          ),
        ],
      ),
    );
  }

  void _handleSessionExpired() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Session Ended'),
        content: Text(
          _saveState == SaveButtonState.mutualSaved
              ? 'Your session has ended, but your match with ${widget.match.name} was saved!'
              : 'Your After Hours session has ended.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context); // Close dialog
              Navigator.pop(context); // Close chat
            },
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  Future<void> _markMessagesAsRead() async {
    final socketService = context.read<SocketService>();
    if (socketService.isConnected) {
      // Method exists in socket_service.dart from Phase 4
      await socketService.markAfterHoursMessagesRead(matchId: widget.match.id);
    }
  }

  bool _isNearBottom() {
    if (!_scrollController.hasClients) return true;
    return _scrollController.position.pixels < 100.0;
  }

  void _scrollToBottom({bool animated = false}) {
    if (!_scrollController.hasClients) return;
    if (animated) {
      _scrollController.animateTo(0,
          duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
    } else {
      _scrollController.jumpTo(0);
    }
  }

  @override
  Widget build(BuildContext context) {
    final afterHoursService = context.watch<AfterHoursService>();
    final authService = context.watch<AuthService>();
    final currentUserId = authService.userId;

    return Scaffold(
      backgroundColor: VlvtColors.background,
      appBar: AppBar(
        backgroundColor: VlvtColors.background,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        titleSpacing: 0,
        title: Row(
          children: [
            if (widget.match.photoUrl != null)
              Padding(
                padding: const EdgeInsets.only(right: 10),
                child: CircleAvatar(
                  radius: 18,
                  backgroundImage: CachedNetworkImageProvider(widget.match.photoUrl!),
                ),
              ),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(widget.match.name, style: VlvtTextStyles.labelLarge),
                  Text(
                    'After Hours',
                    style: VlvtTextStyles.labelSmall.copyWith(
                      color: VlvtColors.gold,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          if (afterHoursService.expiresAt != null)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: Center(
                child: SessionTimer(
                  expiresAt: afterHoursService.expiresAt!,
                  onExpired: _handleSessionExpired,
                  onWarning: () => HapticFeedback.heavyImpact(),
                ),
              ),
            ),
        ],
      ),
      body: Column(
        children: [
          // Expiry banner if in expiring state
          if (afterHoursService.state == AfterHoursState.expiring)
            SessionExpiryBanner(
              secondsRemaining: afterHoursService.remainingSeconds,
            ),

          // Messages list
          Expanded(
            child: _isLoading
                ? const Center(child: VlvtLoader())
                : _buildMessagesList(currentUserId),
          ),

          // Save button
          _buildSaveButton(),

          // Message input
          _buildMessageInput(),
        ],
      ),
    );
  }

  Widget _buildSaveButton() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: VlvtColors.surface,
        border: Border(
          top: BorderSide(color: VlvtColors.border, width: 0.5),
        ),
      ),
      child: SaveMatchButton(
        state: _saveState,
        onSave: _saveState == SaveButtonState.notSaved ||
                _saveState == SaveButtonState.partnerSavedFirst
            ? _saveMatch
            : null,
      ),
    );
  }

  Widget _buildMessagesList(String? currentUserId) {
    if (_messages.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.chat_bubble_outline, size: 64, color: VlvtColors.textMuted),
            const SizedBox(height: 12),
            Text('Start chatting!', style: VlvtTextStyles.bodyMedium.copyWith(
              color: VlvtColors.textSecondary,
            )),
            const SizedBox(height: 4),
            Text(
              'Say hi to ${widget.match.name}',
              style: VlvtTextStyles.bodySmall.copyWith(color: VlvtColors.textMuted),
            ),
          ],
        ),
      );
    }

    final itemCount = _messages.length + (_otherUserTyping ? 1 : 0);

    return ListView.builder(
      controller: _scrollController,
      reverse: true,
      padding: const EdgeInsets.all(16),
      itemCount: itemCount,
      itemBuilder: (context, index) {
        if (_otherUserTyping && index == 0) {
          return _buildTypingIndicator();
        }

        final messageIndex = _otherUserTyping ? index - 1 : index;
        final reversedIndex = _messages.length - 1 - messageIndex;
        final message = _messages[reversedIndex];
        final isCurrentUser = message.senderId == currentUserId;

        return _buildMessageBubble(message, isCurrentUser);
      },
    );
  }

  Widget _buildTypingIndicator() {
    return Align(
      alignment: Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.only(top: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: VlvtColors.surface,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Text(
          '...',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: VlvtColors.textMuted,
            letterSpacing: 2,
          ),
        ),
      ),
    );
  }

  Widget _buildMessageBubble(Message message, bool isCurrentUser) {
    final isFailed = message.status == MessageStatus.failed;

    final borderRadius = isCurrentUser
        ? const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
            bottomLeft: Radius.circular(20),
            bottomRight: Radius.circular(6),
          )
        : const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
            bottomLeft: Radius.circular(6),
            bottomRight: Radius.circular(20),
          );

    return Align(
      alignment: isCurrentUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.only(top: 8),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
          constraints: BoxConstraints(
            maxWidth: MediaQuery.of(context).size.width * 0.7,
          ),
          decoration: BoxDecoration(
            color: isFailed
                ? VlvtColors.error.withOpacity(0.1)
                : (isCurrentUser ? VlvtColors.chatBubbleSent : VlvtColors.chatBubbleReceived),
            borderRadius: borderRadius,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                message.text,
                style: TextStyle(
                  fontSize: 16,
                  color: isFailed
                      ? VlvtColors.error
                      : (isCurrentUser ? VlvtColors.chatTextSent : VlvtColors.chatTextReceived),
                ),
              ),
              const SizedBox(height: 4),
              Text(
                formatTimestamp(message.timestamp),
                style: TextStyle(
                  fontSize: 11,
                  color: isFailed
                      ? VlvtColors.error.withOpacity(0.8)
                      : (isCurrentUser ? VlvtColors.chatTimestampSent : VlvtColors.chatTimestampReceived),
                ),
              ),
              if (isFailed)
                Text(
                  'Failed to send - tap to retry',
                  style: TextStyle(fontSize: 11, color: VlvtColors.error, fontWeight: FontWeight.bold),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMessageInput() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
      decoration: BoxDecoration(
        color: VlvtColors.surface,
        boxShadow: [
          BoxShadow(
            color: VlvtColors.border.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 3,
            offset: const Offset(0, -1),
          ),
        ],
      ),
      child: SafeArea(
        child: Row(
          children: [
            Expanded(
              child: VlvtInput(
                controller: _messageController,
                hintText: 'Type a message...',
                maxLines: null,
                textCapitalization: TextCapitalization.sentences,
                onSubmitted: (_) => _sendMessage(),
                textInputAction: TextInputAction.send,
                blur: false,
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              onPressed: _sendMessage,
              icon: _isSending
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.send),
              color: VlvtColors.gold,
              iconSize: 28,
            ),
          ],
        ),
      ),
    );
  }
}
```
  </action>
  <verify>
    - `flutter analyze frontend/lib/screens/after_hours_chat_screen.dart` shows no errors
    - Screen compiles and accepts required parameters
  </verify>
  <done>AfterHoursChatScreen created with messaging, timer, and save button</done>
</task>

<task type="auto">
  <name>Task 3: Integrate chat navigation from tab screen</name>
  <files>frontend/lib/screens/after_hours_tab_screen.dart</files>
  <action>
Update AfterHoursTabScreen to navigate to chat when state becomes chatting:

1. Add import:
   ```dart
   import 'after_hours_chat_screen.dart';
   ```

2. Update _acceptMatch method to navigate to chat:
   ```dart
   Future<void> _acceptMatch(AfterHoursMatch match) async {
     final service = context.read<AfterHoursService>();
     await service.acceptMatch();

     if (mounted) {
       Navigator.push(
         context,
         MaterialPageRoute(
           builder: (context) => AfterHoursChatScreen(match: match),
         ),
       );
     }
   }
   ```

3. Update the chatting state case in _buildStateContent to handle return from chat:
   ```dart
   case AfterHoursState.chatting:
     // User is in chat (this screen visible when navigating back)
     final match = afterHoursService.currentMatch;
     if (match != null) {
       return Center(
         child: Column(
           mainAxisAlignment: MainAxisAlignment.center,
           children: [
             Text('In chat with ${match.name}', style: VlvtTextStyles.bodyMedium),
             const SizedBox(height: 16),
             VlvtButton.primary(
               label: 'Return to Chat',
               onPressed: () {
                 Navigator.push(
                   context,
                   MaterialPageRoute(
                     builder: (context) => AfterHoursChatScreen(match: match),
                   ),
                 );
               },
             ),
           ],
         ),
       );
     }
     return Center(
       child: SearchingAnimation(nearbyCount: afterHoursService.nearbyCount),
     );
   ```

4. Also listen for session expiry to handle graceful transition:
   ```dart
   void _onServiceStateChanged() {
     if (!mounted) return;
     final service = context.read<AfterHoursService>();

     if (service.state == AfterHoursState.matched && service.currentMatch != null) {
       // Use boolean flag to prevent duplicate modals
       if (!_isMatchCardShowing) {
         _showMatchCard(service.currentMatch!);
       }
     }

     // Handle session expiry
     if (service.state == AfterHoursState.expired) {
       // Show expiry message if not already showing
       ScaffoldMessenger.of(context).showSnackBar(
         const SnackBar(
           content: Text('Your After Hours session has ended'),
           duration: Duration(seconds: 3),
         ),
       );
     }
   }
   ```
  </action>
  <verify>
    - `flutter analyze frontend/lib/screens/after_hours_tab_screen.dart` shows no errors
    - Accepting match navigates to chat screen
    - Returning from chat shows "Return to Chat" button
  </verify>
  <done>Chat navigation integrated into tab screen flow</done>
</task>

</tasks>

<verification>
1. `cd frontend && flutter analyze` - no errors
2. Premium user sees After Hours tab
3. Profile and preferences screens work and persist data
4. Session can be started with location permission
5. Searching animation shows with timer
6. Match card appears when match found (may need backend simulation)
7. Swipe gestures work for accept/decline
8. Chat screen shows messages, timer, and save button
9. Save flow works (save -> waiting/mutual)
10. Session expiry handled gracefully

**Full Flow Test:**
1. Login as premium test user
2. Navigate to After Hours tab (should be between Discovery and Matches)
3. If profile incomplete, tap to complete profile (add photo + bio)
4. If preferences incomplete, tap to set preferences
5. Select duration (15/30/60 min) and tap Start Session
6. Observe searching animation with timer in app bar
7. When match arrives (may need to simulate via backend):
   - Match card slides up as modal
   - Swipe right or tap Chat to accept
   - Chat screen opens with timer and save button
   - Type and send messages
   - Tap save button to save match
   - Observe partner saved notification if partner saves first
8. End session early via stop button
9. Verify session expiry handling (2 min warning, auto-close)
</verification>

<success_criteria>
- flutter_foreground_task dependency added with Android config
- Chat screen has real-time messaging
- Session timer visible in chat app bar
- Save button visible above message input
- Partner saved triggers button state change
- Mutual save shows celebration dialog
- Session expiry closes chat and navigates back
- Full flow from setup to chat works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-integration/06-05-SUMMARY.md`
</output>
