---
phase: 06-frontend-integration
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - frontend/lib/widgets/after_hours/match_card_overlay.dart
  - frontend/lib/screens/after_hours_tab_screen.dart
autonomous: true

must_haves:
  truths:
    - "Match card appears as modal overlay when match found"
    - "User can swipe right to accept, left to decline"
    - "User can tap Chat or Decline buttons"
    - "Auto-decline timer visible on match card"
    - "Accepting transitions to chatting state"
    - "Declining returns to searching state"
  artifacts:
    - path: "frontend/lib/widgets/after_hours/match_card_overlay.dart"
      provides: "Modal match card with swipe gestures"
      exports: ["MatchCardOverlay"]
      min_lines: 200
  key_links:
    - from: "frontend/lib/widgets/after_hours/match_card_overlay.dart"
      to: "after_hours_service.dart"
      via: "acceptMatch/declineMatch callbacks"
      pattern: "onAccept|onDecline"
    - from: "frontend/lib/screens/after_hours_tab_screen.dart"
      to: "match_card_overlay.dart"
      via: "showModalBottomSheet when matched"
      pattern: "MatchCardOverlay"
---

<objective>
Create the match card overlay with Tinder-style swipe gestures for accepting or declining After Hours matches.

Purpose: When a match is found, users need an intuitive way to quickly decide to chat or pass, with familiar swipe gestures and clear visual feedback.

Output: Match card modal with swipe gestures, action buttons, and auto-decline timer integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-frontend-integration/06-CONTEXT.md
@.planning/phases/06-frontend-integration/06-RESEARCH.md

Reference prior plan summaries (if available):
@.planning/phases/06-frontend-integration/06-01-SUMMARY.md

Reference existing patterns:
@frontend/lib/screens/discovery_screen.dart (swipe gesture implementation - lines 447-544)
@frontend/lib/services/after_hours_service.dart (AfterHoursMatch model)
@frontend/lib/theme/vlvt_colors.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create match card overlay widget</name>
  <files>frontend/lib/widgets/after_hours/match_card_overlay.dart</files>
  <action>
Create MatchCardOverlay widget following discovery_screen.dart swipe patterns:

```dart
/// Match Card Overlay Widget
/// Shows After Hours match as modal with swipe gestures
library;

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../../services/after_hours_service.dart';
import '../../theme/vlvt_colors.dart';
import '../../theme/vlvt_text_styles.dart';
import '../../widgets/vlvt_button.dart';

class MatchCardOverlay extends StatefulWidget {
  final AfterHoursMatch match;
  final VoidCallback onAccept;
  final VoidCallback onDecline;

  const MatchCardOverlay({
    super.key,
    required this.match,
    required this.onAccept,
    required this.onDecline,
  });

  @override
  State<MatchCardOverlay> createState() => _MatchCardOverlayState();
}

class _MatchCardOverlayState extends State<MatchCardOverlay>
    with SingleTickerProviderStateMixin {
  // Swipe state
  Offset _cardPosition = Offset.zero;
  double _cardRotation = 0.0;
  bool _isDragging = false;

  // Animation
  late AnimationController _swipeAnimationController;
  late Animation<Offset> _swipeAnimation;

  // Auto-decline timer
  Timer? _autoDeclineTimer;
  Duration _timeRemaining = Duration.zero;

  @override
  void initState() {
    super.initState();
    _swipeAnimationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );

    // Initialize auto-decline timer if deadline set
    if (widget.match.autoDeclineAt != null) {
      _timeRemaining = widget.match.autoDeclineAt!.difference(DateTime.now());
      if (_timeRemaining.isNegative) {
        _timeRemaining = Duration.zero;
      }
      _startAutoDeclineTimer();
    }
  }

  @override
  void dispose() {
    _swipeAnimationController.dispose();
    _autoDeclineTimer?.cancel();
    super.dispose();
  }

  void _startAutoDeclineTimer() {
    _autoDeclineTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }

      setState(() {
        _timeRemaining = widget.match.autoDeclineAt!.difference(DateTime.now());
        if (_timeRemaining.isNegative) {
          _timeRemaining = Duration.zero;
          timer.cancel();
          // Auto-decline handled by backend, just close overlay
        }
      });
    });
  }

  void _onPanStart(DragStartDetails details) {
    HapticFeedback.selectionClick();
    setState(() {
      _isDragging = true;
    });
  }

  void _onPanUpdate(DragUpdateDetails details) {
    if (!_isDragging) return;

    setState(() {
      _cardPosition += details.delta;
      // Calculate rotation based on horizontal position (max 20 degrees)
      _cardRotation = (_cardPosition.dx / 1000).clamp(-0.35, 0.35);
    });
  }

  void _onPanEnd(DragEndDetails details) {
    if (!_isDragging) return;

    final screenWidth = MediaQuery.of(context).size.width;
    final threshold = screenWidth * 0.25; // 25% of screen width

    setState(() {
      _isDragging = false;
    });

    // Check if swiped far enough
    if (_cardPosition.dx.abs() > threshold) {
      final swipeRight = _cardPosition.dx > 0;

      // Animate card off screen
      final targetX = swipeRight ? screenWidth * 1.5 : -screenWidth * 1.5;
      _swipeAnimation = Tween<Offset>(
        begin: _cardPosition,
        end: Offset(targetX, _cardPosition.dy),
      ).animate(CurvedAnimation(
        parent: _swipeAnimationController,
        curve: Curves.easeOut,
      ));

      _swipeAnimationController.forward(from: 0).then((_) {
        if (swipeRight) {
          HapticFeedback.mediumImpact();
          widget.onAccept();
        } else {
          HapticFeedback.lightImpact();
          widget.onDecline();
        }
      });
    } else {
      // Snap back to center
      _swipeAnimation = Tween<Offset>(
        begin: _cardPosition,
        end: Offset.zero,
      ).animate(CurvedAnimation(
        parent: _swipeAnimationController,
        curve: Curves.elasticOut,
      ));

      _swipeAnimationController.forward(from: 0).then((_) {
        if (mounted) {
          setState(() {
            _cardPosition = Offset.zero;
            _cardRotation = 0.0;
          });
          _swipeAnimationController.reset();
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final minutes = _timeRemaining.inMinutes;
    final seconds = _timeRemaining.inSeconds % 60;

    return Container(
      decoration: BoxDecoration(
        color: VlvtColors.background,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Drag handle
          Container(
            margin: const EdgeInsets.only(top: 12),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: VlvtColors.border,
              borderRadius: BorderRadius.circular(2),
            ),
          ),

          // Auto-decline timer
          if (widget.match.autoDeclineAt != null)
            Padding(
              padding: const EdgeInsets.only(top: 12),
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: _timeRemaining.inSeconds <= 60
                      ? VlvtColors.crimson.withOpacity(0.2)
                      : VlvtColors.gold.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.timer,
                      size: 14,
                      color: _timeRemaining.inSeconds <= 60
                          ? VlvtColors.crimson
                          : VlvtColors.gold,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      '${minutes}:${seconds.toString().padLeft(2, '0')} to respond',
                      style: TextStyle(
                        fontFamily: 'Montserrat',
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: _timeRemaining.inSeconds <= 60
                            ? VlvtColors.crimson
                            : VlvtColors.gold,
                      ),
                    ),
                  ],
                ),
              ),
            ),

          // Match card
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: GestureDetector(
                onPanStart: _onPanStart,
                onPanUpdate: _onPanUpdate,
                onPanEnd: _onPanEnd,
                child: AnimatedBuilder(
                  animation: _swipeAnimationController,
                  child: _buildMatchCard(),
                  builder: (context, child) {
                    final position = _swipeAnimationController.isAnimating
                        ? _swipeAnimation.value
                        : _cardPosition;

                    return Transform.translate(
                      offset: position,
                      child: Transform.rotate(
                        angle: _cardRotation,
                        child: Stack(
                          children: [
                            child!,
                            // Swipe indicators
                            if (_isDragging || _swipeAnimationController.isAnimating) ...[
                              if (position.dx > 40)
                                Positioned(
                                  top: 40,
                                  left: 24,
                                  child: Transform.rotate(
                                    angle: -0.4,
                                    child: _buildSwipeLabel('CHAT', VlvtColors.success),
                                  ),
                                ),
                              if (position.dx < -40)
                                Positioned(
                                  top: 40,
                                  right: 24,
                                  child: Transform.rotate(
                                    angle: 0.4,
                                    child: _buildSwipeLabel('PASS', VlvtColors.crimson),
                                  ),
                                ),
                            ],
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
          ),

          // Action buttons
          Padding(
            padding: const EdgeInsets.fromLTRB(24, 0, 24, 24),
            child: Row(
              children: [
                Expanded(
                  child: VlvtButton.secondary(
                    label: 'Decline',
                    onPressed: () {
                      HapticFeedback.lightImpact();
                      widget.onDecline();
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: VlvtButton.primary(
                    label: 'Chat',
                    onPressed: () {
                      HapticFeedback.mediumImpact();
                      widget.onAccept();
                    },
                  ),
                ),
              ],
            ),
          ),

          // Safe area padding
          SizedBox(height: MediaQuery.of(context).padding.bottom),
        ],
      ),
    );
  }

  Widget _buildMatchCard() {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Stack(
          fit: StackFit.expand,
          children: [
            // Photo
            if (widget.match.photoUrl != null && widget.match.photoUrl!.isNotEmpty)
              CachedNetworkImage(
                imageUrl: widget.match.photoUrl!,
                fit: BoxFit.cover,
                placeholder: (context, url) => Container(
                  color: VlvtColors.surface,
                  child: const Center(child: CircularProgressIndicator()),
                ),
                errorWidget: (context, url, error) => Container(
                  color: VlvtColors.surface,
                  child: Icon(Icons.person, size: 80, color: VlvtColors.textMuted),
                ),
              )
            else
              Container(
                color: VlvtColors.surface,
                child: Icon(Icons.person, size: 80, color: VlvtColors.textMuted),
              ),

            // Gradient overlay for text readability
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Container(
                height: 200,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.transparent,
                      Colors.black.withOpacity(0.8),
                    ],
                  ),
                ),
              ),
            ),

            // Profile info
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        widget.match.name,
                        style: VlvtTextStyles.h2.copyWith(
                          color: Colors.white,
                          shadows: [
                            Shadow(
                              color: Colors.black.withOpacity(0.5),
                              blurRadius: 4,
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Text(
                        '${widget.match.age}',
                        style: VlvtTextStyles.h3.copyWith(
                          color: Colors.white.withOpacity(0.9),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 4),
                  Row(
                    children: [
                      Icon(
                        Icons.location_on,
                        size: 14,
                        color: Colors.white.withOpacity(0.8),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${widget.match.distance.toStringAsFixed(1)} km away',
                        style: VlvtTextStyles.bodySmall.copyWith(
                          color: Colors.white.withOpacity(0.8),
                        ),
                      ),
                    ],
                  ),
                  if (widget.match.bio != null && widget.match.bio!.isNotEmpty) ...[
                    const SizedBox(height: 8),
                    Text(
                      widget.match.bio!,
                      style: VlvtTextStyles.bodyMedium.copyWith(
                        color: Colors.white.withOpacity(0.9),
                      ),
                      maxLines: 3,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSwipeLabel(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        border: Border.all(color: color, width: 3),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontFamily: 'Montserrat',
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: color,
          shadows: [
            Shadow(
              color: Colors.black.withOpacity(0.3),
              blurRadius: 4,
            ),
          ],
        ),
      ),
    );
  }
}
```
  </action>
  <verify>
    - `flutter analyze frontend/lib/widgets/after_hours/match_card_overlay.dart` shows no errors
    - Widget compiles and accepts required parameters
  </verify>
  <done>MatchCardOverlay widget created with swipe gestures, auto-decline timer, and action buttons</done>
</task>

<task type="auto">
  <name>Task 2: Integrate match card into tab screen</name>
  <files>frontend/lib/screens/after_hours_tab_screen.dart</files>
  <action>
Update AfterHoursTabScreen to show match card overlay when state transitions to matched:

1. Add import at top:
   ```dart
   import '../widgets/after_hours/match_card_overlay.dart';
   ```

2. Add listener for state changes. In initState, add after _loadSetupData():
   ```dart
   // Listen for match state to show overlay
   WidgetsBinding.instance.addPostFrameCallback((_) {
     context.read<AfterHoursService>().addListener(_onServiceStateChanged);
   });
   ```

3. Add method:
   ```dart
   void _onServiceStateChanged() {
     final service = context.read<AfterHoursService>();
     if (service.state == AfterHoursState.matched && service.currentMatch != null) {
       _showMatchCard(service.currentMatch!);
     }
   }
   ```

4. Remove listener in dispose:
   ```dart
   @override
   void dispose() {
     context.read<AfterHoursService>().removeListener(_onServiceStateChanged);
     WidgetsBinding.instance.removeObserver(this);
     super.dispose();
   }
   ```

5. Add _showMatchCard method:
   ```dart
   void _showMatchCard(AfterHoursMatch match) {
     HapticFeedback.heavyImpact();

     showModalBottomSheet(
       context: context,
       isScrollControlled: true,
       backgroundColor: Colors.transparent,
       isDismissible: false, // Require explicit accept/decline
       enableDrag: false, // Disable default drag-to-dismiss
       builder: (context) => DraggableScrollableSheet(
         initialChildSize: 0.85,
         minChildSize: 0.5,
         maxChildSize: 0.95,
         builder: (context, scrollController) => MatchCardOverlay(
           match: match,
           onAccept: () {
             Navigator.pop(context);
             _acceptMatch(match);
           },
           onDecline: () {
             Navigator.pop(context);
             _declineMatch(match);
           },
         ),
       ),
     );
   }
   ```

6. Add accept/decline methods:
   ```dart
   Future<void> _acceptMatch(AfterHoursMatch match) async {
     final service = context.read<AfterHoursService>();
     await service.acceptMatch();
     // Navigation to chat will be handled in Plan 05
   }

   Future<void> _declineMatch(AfterHoursMatch match) async {
     final service = context.read<AfterHoursService>();
     await service.declineMatch();
   }
   ```

7. Update the matched state case in _buildStateContent to be a placeholder (since overlay shows):
   ```dart
   case AfterHoursState.matched:
     // Match card shown as modal overlay
     return Center(
       child: SearchingAnimation(
         nearbyCount: afterHoursService.nearbyCount,
       ),
     );
   ```

8. Also need to handle the case where the match card is auto-dismissed (match expired).
   Add listener cleanup check:
   ```dart
   void _onServiceStateChanged() {
     if (!mounted) return;
     final service = context.read<AfterHoursService>();
     if (service.state == AfterHoursState.matched && service.currentMatch != null) {
       // Only show if not already showing
       if (ModalRoute.of(context)?.isCurrent ?? true) {
         _showMatchCard(service.currentMatch!);
       }
     }
   }
   ```
  </action>
  <verify>
    - `flutter analyze frontend/lib/screens/after_hours_tab_screen.dart` shows no errors
    - When state becomes matched, modal overlay appears
    - Swiping right calls acceptMatch
    - Swiping left calls declineMatch
    - Tapping Chat/Decline buttons works
  </verify>
  <done>Match card overlay integrated into tab screen, appears when match found</done>
</task>

</tasks>

<verification>
1. `cd frontend && flutter analyze` - no errors
2. Start After Hours session (may need to mock match event for testing)
3. When match arrives, modal slides up with match info
4. Swipe right - see CHAT label, closes modal, transitions to chatting state
5. Swipe left - see PASS label, closes modal, returns to searching state
6. Tap Chat button - same as swipe right
7. Tap Decline button - same as swipe left
8. Auto-decline timer visible and counts down
</verification>

<success_criteria>
- Match card appears as modal overlay when state becomes matched
- Photo, name, age, distance, and bio displayed
- Swipe right to accept (CHAT indicator appears during swipe)
- Swipe left to decline (PASS indicator appears during swipe)
- Button alternatives available for tap-based interaction
- Auto-decline timer visible if autoDeclineAt set
- Modal cannot be dismissed by tapping outside or default drag
- Haptic feedback on swipe completion
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-integration/06-04-SUMMARY.md`
</output>
