---
phase: 04-real-time-chat
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/chat-service/src/jobs/message-cleanup-job.ts
  - backend/chat-service/src/socket/after-hours-handler.ts
  - backend/chat-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Messages are retained server-side for 30 days after session expires"
    - "Messages for unsaved matches are deleted after 30-day retention"
    - "Users receive 2-minute warning before session expires"
    - "Users receive notification when session expires"
  artifacts:
    - path: "backend/chat-service/src/jobs/message-cleanup-job.ts"
      provides: "BullMQ job for 30-day message cleanup"
      exports: ["initializeMessageCleanupJob"]
    - path: "backend/chat-service/src/socket/after-hours-handler.ts"
      provides: "Session expiry notification handlers"
      contains: "session_expiring"
  key_links:
    - from: "message-cleanup-job.ts"
      to: "after_hours_messages table"
      via: "DELETE query"
      pattern: "DELETE FROM after_hours_messages"
    - from: "profile-service session-scheduler"
      to: "after-hours-handler.ts"
      via: "Redis pub/sub"
      pattern: "after_hours:session_expiring"
---

<objective>
Implement 30-day message retention cleanup and session expiry notifications

Purpose: Safety requirement - retain messages server-side for potential moderation even after ephemeral UI deletion. Notify users before session expires so they can save the match.

Output:
- message-cleanup-job.ts with BullMQ scheduled cleanup
- Session expiry notification handling in after-hours-handler.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-CONTEXT.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md

# Existing patterns to follow
@backend/profile-service/src/services/session-scheduler.ts
@backend/profile-service/src/services/matching-scheduler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message cleanup job for 30-day retention</name>
  <files>backend/chat-service/src/jobs/message-cleanup-job.ts, backend/chat-service/src/index.ts</files>
  <action>
Create `backend/chat-service/src/jobs/message-cleanup-job.ts`:

```typescript
/**
 * Message Cleanup Job
 *
 * Scheduled BullMQ job that runs daily at 3 AM UTC to clean up
 * After Hours messages that are older than 30 days for matches
 * that were NOT saved (converted_to_match_id IS NULL).
 *
 * Safety: Messages are retained 30 days server-side even if
 * the UI shows them as "deleted" - for moderation/report purposes.
 */

import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { Pool } from 'pg';
import logger from '../utils/logger';

const CLEANUP_QUEUE_NAME = 'after-hours-message-cleanup';
const RETENTION_DAYS = 30;

let cleanupQueue: Queue | null = null;
let cleanupWorker: Worker | null = null;
let redisConnection: IORedis | null = null;

export async function initializeMessageCleanupJob(pool: Pool): Promise<void> {
  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

  redisConnection = new IORedis(redisUrl, {
    maxRetriesPerRequest: null,
    enableReadyCheck: false,
  });

  // Wait for connection
  await new Promise<void>((resolve, reject) => {
    const timeout = setTimeout(() => reject(new Error('Redis timeout')), 10000);

    redisConnection!.once('ready', () => {
      clearTimeout(timeout);
      logger.info('Redis connected for message cleanup job');
      resolve();
    });

    redisConnection!.once('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });

  cleanupQueue = new Queue(CLEANUP_QUEUE_NAME, { connection: redisConnection });

  // Schedule daily cleanup at 3 AM UTC
  await cleanupQueue.upsertJobScheduler(
    'daily-cleanup',
    { pattern: '0 3 * * *' }, // Cron: 3 AM daily
    { name: 'cleanup-expired-messages', data: {} }
  );

  cleanupWorker = new Worker(
    CLEANUP_QUEUE_NAME,
    async (job: Job) => {
      if (job.name === 'cleanup-expired-messages') {
        await cleanupExpiredMessages(pool);
      }
    },
    { connection: redisConnection }
  );

  cleanupWorker.on('failed', (job, err) => {
    logger.error('Message cleanup job failed', { jobId: job?.id, error: err.message });
  });

  cleanupWorker.on('completed', (job) => {
    logger.info('Message cleanup job completed', { jobId: job.id });
  });

  logger.info('Message cleanup job scheduled', { schedule: '3 AM UTC daily' });
}

async function cleanupExpiredMessages(pool: Pool): Promise<void> {
  try {
    // Delete messages where:
    // 1. Match expired more than 30 days ago
    // 2. Match was NOT saved (converted_to_match_id IS NULL)
    const messagesResult = await pool.query(
      `DELETE FROM after_hours_messages
       WHERE match_id IN (
         SELECT id FROM after_hours_matches
         WHERE expires_at < NOW() - INTERVAL '${RETENTION_DAYS} days'
           AND converted_to_match_id IS NULL
       )
       RETURNING id`
    );

    const deletedMessageCount = messagesResult.rows.length;

    // Also clean up the expired matches themselves
    const matchesResult = await pool.query(
      `DELETE FROM after_hours_matches
       WHERE expires_at < NOW() - INTERVAL '${RETENTION_DAYS} days'
         AND converted_to_match_id IS NULL
       RETURNING id`
    );

    const deletedMatchCount = matchesResult.rows.length;

    if (deletedMessageCount > 0 || deletedMatchCount > 0) {
      logger.info('Cleaned up expired After Hours data', {
        deletedMessages: deletedMessageCount,
        deletedMatches: deletedMatchCount,
        retentionDays: RETENTION_DAYS,
      });
    }
  } catch (error: any) {
    logger.error('Failed to cleanup expired messages', { error: error.message });
    throw error;
  }
}

export async function closeMessageCleanupJob(): Promise<void> {
  if (cleanupWorker) {
    await cleanupWorker.close();
    cleanupWorker = null;
  }

  if (cleanupQueue) {
    await cleanupQueue.close();
    cleanupQueue = null;
  }

  if (redisConnection) {
    redisConnection.disconnect();
    redisConnection = null;
  }

  logger.info('Message cleanup job closed');
}
```

**Update index.ts:**
- Import `initializeMessageCleanupJob` and `closeMessageCleanupJob`
- Call `initializeMessageCleanupJob(pool)` during startup (fire-and-forget with error logging)
- Call `closeMessageCleanupJob()` during graceful shutdown
  </action>
  <verify>
TypeScript compiles:
```bash
cd backend/chat-service && npm run build
```
Grep for RETENTION_DAYS and cron pattern
  </verify>
  <done>
- message-cleanup-job.ts exists with 30-day retention logic
- BullMQ scheduled job runs at 3 AM UTC daily
- Deletes messages + matches older than 30 days where NOT saved
- Job integrated into chat-service startup/shutdown
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session expiry notification handling</name>
  <files>backend/chat-service/src/socket/after-hours-handler.ts, backend/profile-service/src/services/session-scheduler.ts</files>
  <action>
This task adds session expiry warnings. The events are published by profile-service and relayed by chat-service.

**1. Update profile-service session-scheduler.ts** to publish expiry warnings:

Add a new job type `session-expiring-warning` that fires 2 minutes before session expires.

In `handleSessionExpiry` (or add new scheduled job):
```typescript
// 2 minutes before expiry, publish warning
// This should be scheduled when session starts

export async function scheduleSessionExpiryWarning(
  userId: string,
  sessionId: string,
  expiresAt: Date
): Promise<void> {
  if (!sessionQueue) return;

  const warningTime = new Date(expiresAt.getTime() - 2 * 60 * 1000); // 2 min before
  const delayMs = Math.max(0, warningTime.getTime() - Date.now());

  await sessionQueue.add(
    'session-expiring-warning',
    { userId, sessionId, expiresAt: expiresAt.toISOString() },
    {
      delay: delayMs,
      jobId: `session-warning:${sessionId}`,
      removeOnComplete: true,
      removeOnFail: 10,
    }
  );

  logger.info('Scheduled session expiry warning', {
    sessionId,
    warningAt: warningTime.toISOString(),
  });
}
```

In session-scheduler worker, handle `session-expiring-warning`:
```typescript
case 'session-expiring-warning':
  // Publish via Redis pub/sub (same pattern as matching-scheduler)
  await publishSessionEvent('after_hours:session_expiring', job.data.userId, {
    sessionId: job.data.sessionId,
    expiresAt: job.data.expiresAt,
    minutesRemaining: 2,
  });
  break;
```

Also publish `after_hours:session_expired` when session actually expires (in `handleSessionExpiry`):
```typescript
await publishSessionEvent('after_hours:session_expired', userId, {
  sessionId,
  reason: 'timeout',
});
```

**2. Add publishSessionEvent to session-scheduler.ts:**
Create Redis publisher (follow matching-scheduler pattern) or reuse if shared module exists.

**3. Verify after-hours-handler.ts already relays these events:**
The Redis subscriber created in 04-01 should already relay `after_hours:session_expiring` and `after_hours:session_expired` events to Socket.IO clients since it handles all events from `after_hours:events` channel.

**4. Call scheduleSessionExpiryWarning from session start:**
In the session start endpoint (after-hours.ts routes), after creating session:
```typescript
scheduleSessionExpiryWarning(userId, sessionId, expiresAt);
```
  </action>
  <verify>
TypeScript compiles in both services:
```bash
cd backend/profile-service && npm run build
cd backend/chat-service && npm run build
```
Grep for `session_expiring` in session-scheduler.ts
  </verify>
  <done>
- Session expiry warning scheduled 2 minutes before expiry
- `after_hours:session_expiring` event published via Redis pub/sub
- `after_hours:session_expired` event published when session expires
- Events relayed to connected users via existing Redis subscriber in chat-service
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in chat-service and profile-service
2. Grep for cron pattern `0 3 * * *` in message-cleanup-job.ts
3. Grep for `after_hours:session_expiring` in session-scheduler.ts
4. Verify RETENTION_DAYS = 30 in cleanup job
</verification>

<success_criteria>
- Messages retained for 30 days after match expires (safety requirement)
- Messages + matches deleted only after 30 days AND if not saved
- Users receive `after_hours:session_expiring` 2 minutes before expiry
- Users receive `after_hours:session_expired` when session ends
- Cleanup job runs daily at 3 AM UTC
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-03-SUMMARY.md`
</output>
