---
phase: 04-real-time-chat
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/chat-service/src/socket/after-hours-handler.ts
  - backend/chat-service/src/routes/after-hours-chat.ts
  - backend/chat-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Users can send messages in After Hours matches"
    - "Users can see typing indicators in After Hours chat"
    - "Messages are stored in after_hours_messages table"
    - "Users can retrieve chat history when reopening app"
  artifacts:
    - path: "backend/chat-service/src/socket/after-hours-handler.ts"
      provides: "send_message, typing, mark_read handlers"
      contains: "after_hours:send_message"
    - path: "backend/chat-service/src/routes/after-hours-chat.ts"
      provides: "GET /after-hours/messages/:matchId endpoint"
      exports: ["router"]
  key_links:
    - from: "after-hours-handler.ts"
      to: "after_hours_messages table"
      via: "INSERT INTO after_hours_messages"
      pattern: "INSERT INTO after_hours_messages"
    - from: "after-hours-chat.ts"
      to: "after_hours_messages table"
      via: "SELECT query"
      pattern: "SELECT.*FROM after_hours_messages"
---

<objective>
Implement ephemeral message sending, typing indicators, and message history retrieval for After Hours chat

Purpose: Enable real-time messaging within After Hours matches. Messages are stored in after_hours_messages table and retrieved via HTTP when app reopens mid-session.

Output:
- Extended after-hours-handler.ts with message/typing/read handlers
- New after-hours-chat.ts route for message history
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-CONTEXT.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md

# Existing patterns to follow
@backend/chat-service/src/socket/message-handler.ts
@backend/migrations/021_add_after_hours_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message handlers to after-hours-handler.ts</name>
  <files>backend/chat-service/src/socket/after-hours-handler.ts</files>
  <action>
Extend `backend/chat-service/src/socket/after-hours-handler.ts` to add message handlers inside `setupAfterHoursHandlers`:

1. **after_hours:send_message handler:**
   ```typescript
   interface AfterHoursSendMessageData {
     matchId: string;
     text: string;
     tempId?: string;
   }
   ```
   - Validate input: matchId required, text required and non-empty, max 2000 chars
   - Query `after_hours_matches` to verify:
     - Match exists and user is user_id_1 or user_id_2
     - Match is active: `declined_by IS NULL AND expires_at > NOW()`
   - If match expired/declined, return `{ success: false, error: 'Match has expired', code: 'MATCH_EXPIRED' }`
   - Insert into `after_hours_messages (match_id, sender_id, text)` - UUID auto-generated
   - Calculate recipientId (other user in match)
   - Acknowledge to sender: `callback({ success: true, message: {...} })`
   - Emit to recipient: `io.to(\`user:${recipientId}\`).emit('after_hours:new_message', message)`
   - Also emit to match room for multi-device: `io.to(\`after_hours:match:${matchId}\`).emit('after_hours:new_message', message)`

2. **after_hours:typing handler:**
   ```typescript
   interface AfterHoursTypingData {
     matchId: string;
     isTyping: boolean;
   }
   ```
   - Validate matchId, verify user is part of match (query after_hours_matches)
   - Calculate recipientId
   - Emit to recipient: `io.to(\`user:${recipientId}\`).emit('after_hours:user_typing', { matchId, userId, isTyping })`
   - No database storage (typing is ephemeral within ephemeral chat)

3. **after_hours:mark_read handler:**
   ```typescript
   interface AfterHoursMarkReadData {
     matchId: string;
     messageIds?: string[];
   }
   ```
   - Validate matchId, verify user is part of match
   - For After Hours: emit read receipt to sender without storing
     - `io.to(\`user:${senderId}\`).emit('after_hours:messages_read', { matchId, messageIds, readBy: userId, readAt: now })`
   - Why no storage: Ephemeral messages don't need persistent read state

4. **Register handlers with rate limiting:**
   ```typescript
   if (rateLimiter) {
     socket.on('after_hours:send_message', rateLimiter.wrapHandler('after_hours:send_message', handleAfterHoursSendMessage));
     socket.on('after_hours:typing', rateLimiter.wrapHandler('after_hours:typing', handleAfterHoursTyping));
     socket.on('after_hours:mark_read', rateLimiter.wrapHandler('after_hours:mark_read', handleAfterHoursMarkRead));
   } else {
     // Fallback without rate limiting
   }
   ```

Follow message-handler.ts patterns exactly for error handling and logging.
  </action>
  <verify>
TypeScript compiles:
```bash
cd backend/chat-service && npm run build
```
  </verify>
  <done>
- after_hours:send_message handler inserts into after_hours_messages
- after_hours:typing handler emits to recipient
- after_hours:mark_read handler emits read receipt
- All handlers validate match ownership and expiry
- Rate limiting applied to all handlers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP endpoint for message history retrieval</name>
  <files>backend/chat-service/src/routes/after-hours-chat.ts, backend/chat-service/src/index.ts</files>
  <action>
Create `backend/chat-service/src/routes/after-hours-chat.ts`:

1. **GET /after-hours/messages/:matchId endpoint:**
   ```typescript
   import { Router, Request, Response, NextFunction } from 'express';
   import { Pool } from 'pg';
   import logger from '../utils/logger';

   export const createAfterHoursChatRouter = (pool: Pool): Router => {
     const router = Router();

     router.get('/after-hours/messages/:matchId', async (req: Request, res: Response, next: NextFunction) => {
       // Implementation
     });

     return router;
   };
   ```

2. **Implementation details:**
   - Extract matchId from params, userId from req.user (JWT auth)
   - Validate matchId is UUID format
   - Verify user is part of match:
     ```sql
     SELECT user_id_1, user_id_2, expires_at, declined_by
     FROM after_hours_matches WHERE id = $1
     ```
   - Check user is user_id_1 or user_id_2, return 403 if not
   - Check match is still valid (for active chat - return messages even if expired for history)
   - Query messages with cursor pagination (optional `before` timestamp param):
     ```sql
     SELECT id, match_id, sender_id, text, created_at
     FROM after_hours_messages
     WHERE match_id = $1
       AND ($2::timestamptz IS NULL OR created_at < $2)
     ORDER BY created_at DESC
     LIMIT 50
     ```
   - Return `{ success: true, messages: [...], hasMore: messages.length === 50 }`
   - Messages ordered newest-first, client reverses for display

3. **Register route in index.ts:**
   - Import `createAfterHoursChatRouter`
   - Add after auth middleware: `app.use('/api', authMiddleware, createAfterHoursChatRouter(pool))`
   - Full path becomes: `GET /api/after-hours/messages/:matchId`

Handle errors with try/catch, log with winston, return 500 on DB errors.
  </action>
  <verify>
TypeScript compiles and endpoint responds:
```bash
cd backend/chat-service && npm run build
```
Grep for route registration in index.ts
  </verify>
  <done>
- GET /api/after-hours/messages/:matchId endpoint exists
- Validates match ownership before returning messages
- Supports cursor pagination with `before` parameter
- Route registered in chat-service index.ts
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Grep for `after_hours:send_message` in after-hours-handler.ts
3. Grep for `after-hours/messages` in routes and index.ts
4. Verify INSERT INTO after_hours_messages pattern exists
</verification>

<success_criteria>
- Users can send messages that persist in after_hours_messages table
- Typing indicators broadcast to chat partner
- Read receipts emitted (not stored - ephemeral)
- HTTP endpoint allows message history retrieval on app reopen
- All operations validate match ownership and expiry status
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-02-SUMMARY.md`
</output>
