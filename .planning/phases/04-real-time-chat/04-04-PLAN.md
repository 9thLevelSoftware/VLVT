---
phase: 04-real-time-chat
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - frontend/lib/services/socket_service.dart
  - frontend/lib/services/after_hours_chat_service.dart
autonomous: true

must_haves:
  truths:
    - "Flutter app receives After Hours match events via Socket.IO"
    - "Users can send messages in After Hours chat"
    - "Users see typing indicators in After Hours chat"
    - "App can retrieve message history on reopen"
  artifacts:
    - path: "frontend/lib/services/socket_service.dart"
      provides: "After Hours event listeners and emitters"
      contains: "after_hours:match"
    - path: "frontend/lib/services/after_hours_chat_service.dart"
      provides: "After Hours chat business logic service"
      exports: ["AfterHoursChatService"]
  key_links:
    - from: "socket_service.dart"
      to: "chat-service Socket.IO"
      via: "socket.on after_hours:*"
      pattern: "_socket!.on\\('after_hours:"
    - from: "after_hours_chat_service.dart"
      to: "chat-service HTTP API"
      via: "http.get /api/after-hours/messages"
      pattern: "after-hours/messages"
---

<objective>
Extend Flutter socket service with After Hours events and create chat service

Purpose: Enable Flutter frontend to receive match events, send messages, and manage After Hours chat state. This completes the client-side real-time infrastructure.

Output:
- Extended socket_service.dart with After Hours event handlers
- New after_hours_chat_service.dart for chat operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-CONTEXT.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md

# Existing patterns to follow
@frontend/lib/services/socket_service.dart
@frontend/lib/services/chat_api_service.dart
@frontend/lib/models/message.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend socket_service.dart with After Hours events</name>
  <files>frontend/lib/services/socket_service.dart</files>
  <action>
Extend `frontend/lib/services/socket_service.dart` with After Hours event handling:

**1. Add stream controllers for After Hours events (in class fields):**
```dart
// After Hours event stream controllers
final _afterHoursMatchController = StreamController<Map<String, dynamic>>.broadcast();
final _afterHoursMessageController = StreamController<Message>.broadcast();
final _afterHoursTypingController = StreamController<Map<String, dynamic>>.broadcast();
final _afterHoursReadController = StreamController<Map<String, dynamic>>.broadcast();
final _sessionExpiringController = StreamController<Map<String, dynamic>>.broadcast();
final _sessionExpiredController = StreamController<Map<String, dynamic>>.broadcast();
final _noMatchesController = StreamController<Map<String, dynamic>>.broadcast();
final _matchExpiredController = StreamController<Map<String, dynamic>>.broadcast();
```

**2. Add stream getters:**
```dart
// After Hours streams
Stream<Map<String, dynamic>> get onAfterHoursMatch => _afterHoursMatchController.stream;
Stream<Message> get onAfterHoursMessage => _afterHoursMessageController.stream;
Stream<Map<String, dynamic>> get onAfterHoursTyping => _afterHoursTypingController.stream;
Stream<Map<String, dynamic>> get onAfterHoursMessagesRead => _afterHoursReadController.stream;
Stream<Map<String, dynamic>> get onSessionExpiring => _sessionExpiringController.stream;
Stream<Map<String, dynamic>> get onSessionExpired => _sessionExpiredController.stream;
Stream<Map<String, dynamic>> get onNoMatches => _noMatchesController.stream;
Stream<Map<String, dynamic>> get onMatchExpired => _matchExpiredController.stream;
```

**3. Add event listeners in _setupEventHandlers():**
```dart
// After Hours: New match found
_socket!.on('after_hours:match', (data) {
  debugPrint('Socket: After Hours match received');
  try {
    if (data is! Map<String, dynamic>) return;
    _afterHoursMatchController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing After Hours match: $e');
  }
});

// After Hours: New message in chat
_socket!.on('after_hours:new_message', (data) {
  debugPrint('Socket: After Hours message received');
  try {
    if (data is! Map<String, dynamic>) return;
    final message = Message.fromJson(data);
    _afterHoursMessageController.add(message);
  } catch (e) {
    debugPrint('Socket: Error parsing After Hours message: $e');
  }
});

// After Hours: Typing indicator
_socket!.on('after_hours:user_typing', (data) {
  try {
    if (data is! Map<String, dynamic>) return;
    _afterHoursTypingController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing After Hours typing: $e');
  }
});

// After Hours: Messages read
_socket!.on('after_hours:messages_read', (data) {
  try {
    if (data is! Map<String, dynamic>) return;
    _afterHoursReadController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing After Hours read receipt: $e');
  }
});

// After Hours: Session expiring warning (2 min)
_socket!.on('after_hours:session_expiring', (data) {
  debugPrint('Socket: Session expiring warning');
  try {
    if (data is! Map<String, dynamic>) return;
    _sessionExpiringController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing session expiring: $e');
  }
});

// After Hours: Session expired
_socket!.on('after_hours:session_expired', (data) {
  debugPrint('Socket: Session expired');
  try {
    if (data is! Map<String, dynamic>) return;
    _sessionExpiredController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing session expired: $e');
  }
});

// After Hours: No matches available
_socket!.on('after_hours:no_matches', (data) {
  try {
    if (data is! Map<String, dynamic>) return;
    _noMatchesController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing no matches: $e');
  }
});

// After Hours: Match expired (auto-decline)
_socket!.on('after_hours:match_expired', (data) {
  debugPrint('Socket: Match expired');
  try {
    if (data is! Map<String, dynamic>) return;
    _matchExpiredController.add(data);
  } catch (e) {
    debugPrint('Socket: Error parsing match expired: $e');
  }
});
```

**4. Add emitter methods for After Hours actions:**
```dart
/// Send an After Hours message
Future<Message?> sendAfterHoursMessage({
  required String matchId,
  required String text,
  String? tempId,
}) async {
  if (!_isConnected || _socket == null) {
    debugPrint('Socket: Cannot send After Hours message - not connected');
    return null;
  }

  final completer = Completer<Message?>();
  bool hasCompleted = false;

  Timer(const Duration(seconds: 10), () {
    if (!hasCompleted) {
      hasCompleted = true;
      completer.complete(null);
    }
  });

  _socket!.emitWithAck('after_hours:send_message', {
    'matchId': matchId,
    'text': text,
    'tempId': tempId,
  }, ack: (response) {
    if (hasCompleted) return;
    hasCompleted = true;
    try {
      if (response is! Map<String, dynamic>) {
        completer.complete(null);
        return;
      }
      if (response['success'] == true) {
        final messageData = response['message'];
        if (messageData is! Map<String, dynamic>) {
          completer.complete(null);
          return;
        }
        completer.complete(Message.fromJson(messageData));
      } else {
        debugPrint('Socket: After Hours send failed: ${response['error']}');
        completer.complete(null);
      }
    } catch (e) {
      completer.complete(null);
    }
  });

  return completer.future;
}

/// Send After Hours typing indicator
Future<void> sendAfterHoursTypingIndicator({
  required String matchId,
  required bool isTyping,
}) async {
  if (!_isConnected || _socket == null) return;

  _socket!.emit('after_hours:typing', {
    'matchId': matchId,
    'isTyping': isTyping,
  });
}

/// Mark After Hours messages as read
Future<bool> markAfterHoursMessagesRead({
  required String matchId,
  List<String>? messageIds,
}) async {
  if (!_isConnected || _socket == null) return false;

  final completer = Completer<bool>();

  _socket!.emitWithAck('after_hours:mark_read', {
    'matchId': matchId,
    if (messageIds != null) 'messageIds': messageIds,
  }, ack: (response) {
    try {
      if (response is! Map<String, dynamic>) {
        completer.complete(false);
        return;
      }
      completer.complete(response['success'] == true);
    } catch (e) {
      completer.complete(false);
    }
  });

  return completer.future;
}

/// Join After Hours chat room
void joinAfterHoursChat(String matchId) {
  if (!_isConnected || _socket == null) return;
  _socket!.emit('after_hours:join_chat', {'matchId': matchId});
}

/// Leave After Hours chat room
void leaveAfterHoursChat(String matchId) {
  if (!_isConnected || _socket == null) return;
  _socket!.emit('after_hours:leave_chat', {'matchId': matchId});
}
```

**5. Close controllers in dispose():**
```dart
@override
void dispose() {
  // ... existing closes
  _afterHoursMatchController.close();
  _afterHoursMessageController.close();
  _afterHoursTypingController.close();
  _afterHoursReadController.close();
  _sessionExpiringController.close();
  _sessionExpiredController.close();
  _noMatchesController.close();
  _matchExpiredController.close();
  super.dispose();
}
```
  </action>
  <verify>
Flutter analyzes without errors:
```bash
cd frontend && flutter analyze
```
  </verify>
  <done>
- Stream controllers for all After Hours events added
- Event listeners registered for all `after_hours:*` events
- Emitter methods for send_message, typing, mark_read, join/leave chat
- All controllers closed in dispose()
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AfterHoursChatService for chat operations</name>
  <files>frontend/lib/services/after_hours_chat_service.dart</files>
  <action>
Create `frontend/lib/services/after_hours_chat_service.dart`:

```dart
/// After Hours Chat Service
/// Handles After Hours chat operations including message history retrieval
/// and message sending with auto-retry
library;

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import '../config/app_config.dart';
import '../models/message.dart';
import 'auth_service.dart';
import 'socket_service.dart';

class AfterHoursChatService extends ChangeNotifier {
  final AuthService _authService;
  final SocketService _socketService;

  // Auto-retry configuration
  static const _maxRetries = 3;
  static const List<int> _retryDelaysMs = [1000, 2000, 4000];

  AfterHoursChatService(this._authService, this._socketService);

  /// Get message history for an After Hours match
  /// Used when user reopens app mid-session
  Future<List<Message>> getMessageHistory({
    required String matchId,
    DateTime? before,
  }) async {
    try {
      final token = await _authService.getToken();
      if (token == null) {
        debugPrint('AfterHoursChatService: No auth token');
        return [];
      }

      final queryParams = <String, String>{};
      if (before != null) {
        queryParams['before'] = before.toIso8601String();
      }

      final uri = Uri.parse(
        '${AppConfig.chatServiceUrl}/api/after-hours/messages/$matchId',
      ).replace(queryParameters: queryParams.isNotEmpty ? queryParams : null);

      final response = await http.get(
        uri,
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        if (data['success'] == true) {
          final messagesJson = data['messages'] as List<dynamic>;
          return messagesJson
              .map((m) => Message.fromJson(m as Map<String, dynamic>))
              .toList();
        }
      }

      debugPrint('AfterHoursChatService: Failed to get history: ${response.statusCode}');
      return [];
    } catch (e) {
      debugPrint('AfterHoursChatService: Error getting history: $e');
      return [];
    }
  }

  /// Send message with auto-retry on failure
  /// Returns the sent Message on success, null after all retries fail
  Future<Message?> sendMessageWithRetry({
    required String matchId,
    required String text,
    required String tempId,
  }) async {
    int attempts = 0;

    while (attempts < _maxRetries) {
      try {
        // Wait for connection if disconnected
        if (!_socketService.isConnected) {
          final connected = await _waitForConnection(
            timeout: const Duration(seconds: 5),
          );
          if (!connected) {
            attempts++;
            if (attempts < _maxRetries) {
              await Future.delayed(Duration(milliseconds: _retryDelaysMs[attempts - 1]));
            }
            continue;
          }
        }

        final message = await _socketService.sendAfterHoursMessage(
          matchId: matchId,
          text: text,
          tempId: tempId,
        );

        if (message != null) {
          return message; // Success
        }

        // Null response = soft failure, retry
        attempts++;
        if (attempts < _maxRetries) {
          await Future.delayed(Duration(milliseconds: _retryDelaysMs[attempts - 1]));
        }
      } catch (e) {
        debugPrint('AfterHoursChatService: Send attempt $attempts failed: $e');
        attempts++;
        if (attempts < _maxRetries) {
          await Future.delayed(Duration(milliseconds: _retryDelaysMs[attempts - 1]));
        }
      }
    }

    // All retries failed
    debugPrint('AfterHoursChatService: All send retries failed');
    return null;
  }

  /// Wait for socket connection with timeout
  Future<bool> _waitForConnection({required Duration timeout}) async {
    final deadline = DateTime.now().add(timeout);

    while (DateTime.now().isBefore(deadline)) {
      if (_socketService.isConnected) return true;
      await Future.delayed(const Duration(milliseconds: 100));
    }

    return false;
  }

  /// Check if currently connected
  bool get isConnected => _socketService.isConnected;
}
```

This service:
- Provides HTTP endpoint access for message history (app reopen scenario)
- Wraps socket sending with auto-retry (3 attempts, exponential backoff)
- Silently retries - only returns null after all attempts fail
- Follows CONTEXT.md: "Auto-retry silently on send failure - only show error after multiple failures"
  </action>
  <verify>
Flutter analyzes without errors:
```bash
cd frontend && flutter analyze
```
  </verify>
  <done>
- after_hours_chat_service.dart exists with getMessageHistory and sendMessageWithRetry
- HTTP endpoint called for message history
- 3-attempt retry with exponential backoff (1s, 2s, 4s)
- Service follows existing AuthService/SocketService dependency patterns
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes without errors
2. Grep for `after_hours:match` event listener in socket_service.dart
3. Grep for `sendAfterHoursMessage` method in socket_service.dart
4. Verify after_hours_chat_service.dart has getMessageHistory and sendMessageWithRetry
</verification>

<success_criteria>
- Flutter app can receive all After Hours Socket.IO events
- App can send messages via socket with auto-retry
- App can retrieve message history via HTTP endpoint
- App can send typing indicators and mark messages read
- All socket streams properly disposed
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-04-SUMMARY.md`
</output>
