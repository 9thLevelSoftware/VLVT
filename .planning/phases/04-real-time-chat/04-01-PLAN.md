---
phase: 04-real-time-chat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/chat-service/src/socket/index.ts
  - backend/chat-service/src/socket/after-hours-handler.ts
autonomous: true

must_haves:
  truths:
    - "Chat-service receives match events from profile-service via Redis"
    - "Match events are delivered to connected users via Socket.IO"
    - "Users can join and leave After Hours match rooms"
  artifacts:
    - path: "backend/chat-service/src/socket/after-hours-handler.ts"
      provides: "After Hours event handlers and Redis subscriber"
      exports: ["initializeAfterHoursRedisSubscriber", "setupAfterHoursHandlers"]
    - path: "backend/chat-service/src/socket/index.ts"
      provides: "Integration with After Hours handlers"
      contains: "setupAfterHoursHandlers"
  key_links:
    - from: "matching-scheduler.ts"
      to: "after-hours-handler.ts"
      via: "Redis pub/sub channel after_hours:events"
      pattern: "subscribe.*after_hours:events"
    - from: "after-hours-handler.ts"
      to: "socket.io"
      via: "io.to(user:userId).emit"
      pattern: "io\\.to\\(.*\\)\\.emit"
---

<objective>
Create Redis pub/sub subscriber in chat-service and After Hours Socket.IO event handlers

Purpose: Bridge the gap between profile-service (which publishes match events to Redis) and connected clients (who receive events via Socket.IO). This is the critical integration layer that enables real-time match delivery.

Output:
- after-hours-handler.ts with Redis subscriber and Socket.IO handlers
- Extended socket/index.ts to initialize After Hours handlers
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md

# Existing patterns to follow
@backend/chat-service/src/socket/index.ts
@backend/chat-service/src/socket/message-handler.ts
@backend/profile-service/src/services/matching-scheduler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create after-hours-handler.ts with Redis subscriber and Socket.IO handlers</name>
  <files>backend/chat-service/src/socket/after-hours-handler.ts</files>
  <action>
Create new file `backend/chat-service/src/socket/after-hours-handler.ts` with:

1. **Redis Pub/Sub Subscriber:**
   - Import ioredis (already in package.json)
   - Create `initializeAfterHoursRedisSubscriber(io: SocketServer)` function
   - Subscribe to `after_hours:events` channel
   - Parse incoming JSON messages with format `{type, targetUserId, payload, timestamp}`
   - Emit to user room `io.to(\`user:${targetUserId}\`).emit(type, payload)`
   - Handle connection errors gracefully (log and continue, non-blocking)
   - Use 10-second timeout on Redis connection

2. **Socket.IO Event Handlers:**
   - Create `setupAfterHoursHandlers(io, socket, pool, rateLimiter)` function
   - `after_hours:join_chat` - Join match room `after_hours:match:${matchId}`, validate user is part of match via DB query
   - `after_hours:leave_chat` - Leave match room
   - Add rate limiter configuration for After Hours events:
     - `after_hours:send_message`: 30 per minute (same as regular)
     - `after_hours:typing`: 10 per 10 seconds
     - `after_hours:mark_read`: 60 per minute

3. **Event Types to Relay from Redis:**
   - `after_hours:match` - New match found
   - `after_hours:no_matches` - No matches available
   - `after_hours:match_expired` - Match auto-declined or expired

Follow existing message-handler.ts patterns:
- Use SocketWithAuth type for typed socket
- Log all events with structured winston logging
- Validate matchId format (UUID) before DB queries

Module exports:
```typescript
export { initializeAfterHoursRedisSubscriber, setupAfterHoursHandlers };
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd backend/chat-service && npm run build
```
  </verify>
  <done>
- after-hours-handler.ts exists with initializeAfterHoursRedisSubscriber and setupAfterHoursHandlers
- TypeScript compiles successfully
- Redis subscriber pattern matches ioredis subscribe/on-message pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate After Hours handlers into socket/index.ts</name>
  <files>backend/chat-service/src/socket/index.ts</files>
  <action>
Modify `backend/chat-service/src/socket/index.ts` to:

1. **Add imports:**
   ```typescript
   import { initializeAfterHoursRedisSubscriber, setupAfterHoursHandlers } from './after-hours-handler';
   ```

2. **Update rate limiter configuration** - Add After Hours event limits:
   ```typescript
   const socketRateLimiter = createSocketRateLimiter({
     limits: {
       // Existing limits...
       send_message: { maxEvents: 30, windowMs: 60000 },
       typing: { maxEvents: 10, windowMs: 10000 },
       mark_read: { maxEvents: 60, windowMs: 60000 },
       get_online_status: { maxEvents: 30, windowMs: 60000 },
       // After Hours limits (same as regular chat)
       'after_hours:send_message': { maxEvents: 30, windowMs: 60000 },
       'after_hours:typing': { maxEvents: 10, windowMs: 10000 },
       'after_hours:mark_read': { maxEvents: 60, windowMs: 60000 },
     },
     // ... rest of config
   });
   ```

3. **Initialize Redis subscriber** in `initializeSocketIO` function:
   - After creating io server, before returning, call:
   ```typescript
   // Initialize After Hours Redis subscriber (non-blocking)
   initializeAfterHoursRedisSubscriber(io).catch(err => {
     logger.warn('Failed to initialize After Hours Redis subscriber', { error: err.message });
   });
   ```
   - Use fire-and-forget pattern - server continues if Redis unavailable

4. **Register After Hours handlers on connection:**
   - In the `io.on('connection', ...)` callback, after `setupMessageHandlers`:
   ```typescript
   // Setup After Hours message event handlers
   setupAfterHoursHandlers(io, socket, pool, socketRateLimiter);
   ```

Preserve all existing functionality - this is additive only.
  </action>
  <verify>
TypeScript compiles and service starts without errors:
```bash
cd backend/chat-service && npm run build && npm run dev &
sleep 3
curl http://localhost:3003/health
```
(Kill dev server after verification)
  </verify>
  <done>
- socket/index.ts imports and initializes After Hours handlers
- Rate limiter includes After Hours event limits
- Redis subscriber initialized on startup (non-blocking)
- After Hours handlers registered on each socket connection
- Service starts successfully
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in chat-service directory
2. Service starts without crashing
3. Grep for key patterns:
   - `after_hours:events` channel subscription
   - `after_hours:join_chat` and `after_hours:leave_chat` handlers
   - Rate limiter entries for `after_hours:*` events
</verification>

<success_criteria>
- Chat-service can subscribe to Redis `after_hours:events` channel
- Match events published by profile-service are relayed to Socket.IO
- Users can join/leave After Hours match rooms via Socket.IO events
- Service degrades gracefully if Redis unavailable (logs warning, continues)
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-01-SUMMARY.md`
</output>
