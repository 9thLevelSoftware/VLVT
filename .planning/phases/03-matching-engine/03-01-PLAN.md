---
phase: 03-matching-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/migrations/023_add_matching_engine_columns.sql
  - backend/profile-service/src/services/matching-engine.ts
autonomous: true

must_haves:
  truths:
    - "Matching query finds active sessions within distance and preference criteria"
    - "Blocked users are excluded bidirectionally"
    - "Already-matched-this-session users are excluded"
    - "Declined users respect 3-session memory"
  artifacts:
    - path: "backend/migrations/023_add_matching_engine_columns.sql"
      provides: "Schema additions for decline tracking and match status"
      contains: "decline_count"
    - path: "backend/profile-service/src/services/matching-engine.ts"
      provides: "Core matching query logic"
      exports: ["findMatchCandidate", "createAfterHoursMatch"]
  key_links:
    - from: "matching-engine.ts"
      to: "after_hours_sessions"
      via: "SQL query with Haversine formula"
      pattern: "6371.*acos"
    - from: "matching-engine.ts"
      to: "after_hours_declines"
      via: "Exclusion subquery"
      pattern: "decline_count"
---

<objective>
Create the core matching engine: database schema additions and the proximity matching query logic.

Purpose: The matching query is the foundation of Phase 3. It finds compatible active users based on location (Haversine formula), mutual preferences (gender, age), and exclusions (blocks, existing matches, declines with 3-session memory).

Output: Migration file with schema additions, matching-engine.ts service with query logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-matching-engine/03-RESEARCH.md

# Existing patterns
@backend/profile-service/src/services/session-scheduler.ts
@backend/profile-service/src/routes/after-hours.ts
@backend/migrations/021_add_after_hours_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for matching engine schema additions</name>
  <files>backend/migrations/023_add_matching_engine_columns.sql</files>
  <action>
Create migration 023 with the following schema changes:

1. Add columns to `after_hours_declines` for 3-session memory:
   - `decline_count INTEGER DEFAULT 1` - tracks how many times declined
   - `first_declined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP`
   - `last_session_id UUID` - the session where last decline occurred
   - Drop existing unique constraint and add new one: `UNIQUE(user_id, declined_user_id)` (removes session_id from constraint since we now track across sessions)

2. Add columns to `after_hours_matches` for decline tracking:
   - `declined_by VARCHAR(255) REFERENCES users(id) ON DELETE SET NULL` - who declined (NULL = not declined)
   - `declined_at TIMESTAMP WITH TIME ZONE` - when declined

3. Add index for active match lookup:
   - `idx_after_hours_matches_active` on `(user_id_1, user_id_2) WHERE declined_by IS NULL AND expires_at > NOW()`

Include appropriate COMMENT ON COLUMN statements explaining each addition.

IMPORTANT: The migration must be idempotent (use IF NOT EXISTS where possible, or use DO $$ blocks for ALTER TABLE).
  </action>
  <verify>
Run migration check: `cd backend/migrations && npm run migrate:check` (if available) or review SQL syntax manually.
Verify no syntax errors by checking file with `psql -f 023_add_matching_engine_columns.sql --echo-all 2>&1 | head -50` against a test database.
  </verify>
  <done>Migration file exists with decline tracking columns, match status columns, and index for active matches.</done>
</task>

<task type="auto">
  <name>Task 2: Create matching-engine.ts service with core query logic</name>
  <files>backend/profile-service/src/services/matching-engine.ts</files>
  <action>
Create the matching engine service with:

1. **Interface definitions:**
   ```typescript
   interface MatchCandidate {
     userId: string;
     sessionId: string;
     name: string;
     age: number;
     photoUrl: string;
     description: string;
     distance: number; // km
     gender: string;
   }

   interface UserPreferences {
     seekingGender: string;
     maxDistanceKm: number;
     minAge: number;
     maxAge: number;
   }
   ```

2. **findMatchCandidate function:**
   - Takes: pool, userId, sessionId, userLocation {lat, lng}, userGender, preferences
   - Returns: MatchCandidate | null
   - SQL query structure (following existing Haversine pattern from index.ts lines 1214-1236):
     - CTE `user_session` for requesting user's session
     - CTE `active_sessions` joining sessions + profiles + after_hours_profiles + preferences
     - Haversine distance calculation: `6371 * acos(cos(radians($lat)) * cos(radians(fuzzed_latitude)) * cos(radians(fuzzed_longitude) - radians($lng)) + sin(radians($lat)) * sin(radians(fuzzed_latitude)))`
     - Exclusions:
       a. Distance <= maxDistanceKm
       b. Mutual gender preference: `(their_seeking = 'Any' OR their_seeking = my_gender) AND (my_seeking = 'Any' OR my_seeking = their_gender)`
       c. Age range: `their_age >= my_min_age AND their_age <= my_max_age`
       d. Blocked users (bidirectional): subquery to `blocks` table
       e. Already matched this session: subquery to `after_hours_matches` where declined_by IS NULL
       f. Declined with 3-session memory: `decline_count < 3` in `after_hours_declines`
       g. Session has >2 minutes remaining: `expires_at > NOW() + INTERVAL '2 minutes'`
     - ORDER BY distance ASC, LIMIT 1

3. **createAfterHoursMatch function:**
   - Takes: pool, user1Id, session1Id, user2Id, session2Id
   - Returns: AfterHoursMatch | null
   - Uses transaction with SELECT FOR UPDATE SKIP LOCKED pattern:
     a. Lock both users' sessions to prevent concurrent matching
     b. If can't lock both (someone else is matching them), return null
     c. Calculate match expiry: MIN(session1.expires_at, session2.expires_at, NOW + 10 minutes)
     d. Insert into after_hours_matches
     e. Return the created match

4. **getActiveUserCountNearby function:**
   - Takes: pool, userLocation {lat, lng}, maxDistanceKm
   - Returns: number
   - Simple COUNT query with Haversine filter (for social proof display)

Use existing logger from `../utils/logger`.
Follow error handling patterns from session-scheduler.ts.
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Exports are accessible: Check that findMatchCandidate, createAfterHoursMatch, getActiveUserCountNearby are exported.
  </verify>
  <done>matching-engine.ts exists with findMatchCandidate (proximity + preference + exclusion query), createAfterHoursMatch (atomic creation with SKIP LOCKED), and getActiveUserCountNearby functions.</done>
</task>

</tasks>

<verification>
1. `npm run build` in profile-service compiles without errors
2. Migration file has valid SQL syntax
3. matching-engine.ts exports the three core functions
4. Haversine formula matches existing pattern in index.ts
</verification>

<success_criteria>
- Migration 023 adds decline_count, first_declined_at, last_session_id to after_hours_declines
- Migration 023 adds declined_by, declined_at to after_hours_matches
- matching-engine.ts findMatchCandidate returns single best candidate with all exclusions
- matching-engine.ts createAfterHoursMatch uses SKIP LOCKED for concurrent safety
- TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-matching-engine/03-01-SUMMARY.md`
</output>
