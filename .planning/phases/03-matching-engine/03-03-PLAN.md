---
phase: 03-matching-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - backend/profile-service/src/routes/after-hours.ts
  - backend/profile-service/src/middleware/after-hours-validation.ts
autonomous: true

must_haves:
  truths:
    - "User can decline current match silently"
    - "Declined match is recorded with 3-session memory"
    - "User can get current match status (match or searching)"
    - "User can get active user count nearby"
  artifacts:
    - path: "backend/profile-service/src/routes/after-hours.ts"
      provides: "Decline, current match, and nearby count endpoints"
      contains: "POST.*decline"
    - path: "backend/profile-service/src/middleware/after-hours-validation.ts"
      provides: "Validation for decline endpoint"
      contains: "validateDecline"
  key_links:
    - from: "after-hours.ts"
      to: "matching-scheduler.ts"
      via: "Trigger matching after decline"
      pattern: "triggerMatchingForUser"
    - from: "after-hours.ts"
      to: "after_hours_declines"
      via: "UPSERT with decline_count increment"
      pattern: "ON CONFLICT.*DO UPDATE"
---

<objective>
Create the decline endpoint, current match status endpoint, and active user count endpoint.

Purpose: Users need to decline matches they're not interested in (triggering the next match), check their current match status (for app reopen), and see how many users are nearby (social proof). Declines are silent and use 3-session memory.

Output: Three new endpoints in after-hours.ts with supporting validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-matching-engine/03-RESEARCH.md

# Prior plan output (matching-scheduler.ts must exist)
@.planning/phases/03-matching-engine/03-02-SUMMARY.md

# Existing patterns
@backend/profile-service/src/routes/after-hours.ts
@backend/profile-service/src/middleware/after-hours-validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation for decline endpoint</name>
  <files>backend/profile-service/src/middleware/after-hours-validation.ts</files>
  <action>
Add validateDecline middleware to after-hours-validation.ts:

```typescript
/**
 * Validate decline request
 * Requires matchId (UUID) in body
 */
export function validateDecline(req: Request, res: Response, next: NextFunction) {
  const { matchId } = req.body;

  if (!matchId) {
    return res.status(400).json({
      success: false,
      error: 'matchId is required',
    });
  }

  // Validate UUID format
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(matchId)) {
    return res.status(400).json({
      success: false,
      error: 'matchId must be a valid UUID',
    });
  }

  next();
}
```

Export the new validator alongside existing validators.
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Export is accessible in import statement test.
  </verify>
  <done>validateDecline middleware exists and is exported.</done>
</task>

<task type="auto">
  <name>Task 2: Add decline, current match, and nearby count endpoints</name>
  <files>backend/profile-service/src/routes/after-hours.ts</files>
  <action>
Add three new endpoints to after-hours.ts:

1. **Add imports at top of file:**
   ```typescript
   // From matching-scheduler.ts (created in 03-02)
   import { triggerMatchingForUser } from '../services/matching-scheduler';
   // From matching-engine.ts (created in 03-01)
   import { getActiveUserCountNearby } from '../services/matching-engine';
   // From validation middleware
   import { validateDecline } from '../middleware/after-hours-validation';
   // IMPORTANT: resolvePhotoUrl is in r2-client.ts, NOT in a photos module
   import { resolvePhotoUrl } from '../utils/r2-client';
   ```

2. **POST /match/decline - Decline current match (silent):**
   ```typescript
   /**
    * POST /match/decline - Decline current match
    *
    * Silently declines the current match. The other user is NOT notified.
    * Records decline with 3-session memory (declined user won't appear for 3 sessions).
    * Triggers matching to find next candidate after 30-second cooldown.
    */
   router.post('/match/decline', validateDecline, async (req: Request, res: Response) => {
     const userId = req.user!.userId;
     const { matchId } = req.body;

     try {
       // Get current active session
       const sessionResult = await pool.query(
         `SELECT id FROM after_hours_sessions WHERE user_id = $1 AND ended_at IS NULL`,
         [userId]
       );

       if (sessionResult.rows.length === 0) {
         return res.status(400).json({
           success: false,
           error: 'No active session',
           code: 'NO_ACTIVE_SESSION',
         });
       }

       const sessionId = sessionResult.rows[0].id;

       // Get the match and verify user is part of it
       const matchResult = await pool.query(
         `SELECT id, user_id_1, user_id_2
          FROM after_hours_matches
          WHERE id = $1
            AND (user_id_1 = $2 OR user_id_2 = $2)
            AND declined_by IS NULL`,
         [matchId, userId]
       );

       if (matchResult.rows.length === 0) {
         return res.status(404).json({
           success: false,
           error: 'Match not found or already declined',
         });
       }

       const match = matchResult.rows[0];
       const declinedUserId = match.user_id_1 === userId ? match.user_id_2 : match.user_id_1;

       // Record decline with 3-session memory (UPSERT pattern)
       await pool.query(
         `INSERT INTO after_hours_declines
          (user_id, declined_user_id, session_id, decline_count, first_declined_at, last_session_id)
          VALUES ($1, $2, $3, 1, NOW(), $3)
          ON CONFLICT (user_id, declined_user_id)
          DO UPDATE SET
            decline_count = CASE
              WHEN after_hours_declines.decline_count >= 3 THEN 1  -- Reset after 3 (they can reappear)
              ELSE after_hours_declines.decline_count + 1
            END,
            last_session_id = $3`,
         [userId, declinedUserId, sessionId]
       );

       // Mark match as declined
       await pool.query(
         `UPDATE after_hours_matches
          SET declined_by = $1, declined_at = NOW()
          WHERE id = $2`,
         [userId, matchId]
       );

       logger.info('Match declined', { userId, matchId, declinedUserId });

       // Trigger matching after 30-second cooldown
       triggerMatchingForUser(userId, sessionId, 30000).catch((err) => {
         logger.error('Failed to trigger matching after decline', { error: err.message });
       });

       res.json({
         success: true,
         message: 'Match declined',
       });
     } catch (error: any) {
       logger.error('Failed to decline match', { error: error.message, userId });
       res.status(500).json({ success: false, error: 'Failed to decline match' });
     }
   });
   ```

3. **GET /match/current - Get current match status:**
   ```typescript
   /**
    * GET /match/current - Get current match status
    *
    * Returns the user's current undeclined match (if any) or searching status.
    * Used when app reopens to restore match card state.
    */
   router.get('/match/current', async (req: Request, res: Response) => {
     const userId = req.user!.userId;

     try {
       // Check for active session first
       const sessionResult = await pool.query(
         `SELECT id, fuzzed_latitude, fuzzed_longitude FROM after_hours_sessions
          WHERE user_id = $1 AND ended_at IS NULL`,
         [userId]
       );

       if (sessionResult.rows.length === 0) {
         return res.json({
           success: true,
           active: false,
           status: 'no_session',
           match: null,
         });
       }

       // Get current undeclined match
       const matchResult = await pool.query(
         `SELECT m.id, m.expires_at, m.created_at,
                 p.name, p.age, ahp.photo_url, ahp.description,
                 s.fuzzed_latitude, s.fuzzed_longitude,
                 m.user_id_1, m.user_id_2
          FROM after_hours_matches m
          JOIN after_hours_sessions s ON
            (m.user_id_1 = $1 AND s.user_id = m.user_id_2 AND s.ended_at IS NULL) OR
            (m.user_id_2 = $1 AND s.user_id = m.user_id_1 AND s.ended_at IS NULL)
          JOIN profiles p ON p.user_id = s.user_id
          JOIN after_hours_profiles ahp ON ahp.user_id = s.user_id
          WHERE (m.user_id_1 = $1 OR m.user_id_2 = $1)
            AND m.declined_by IS NULL
            AND m.expires_at > NOW()
          ORDER BY m.created_at DESC
          LIMIT 1`,
         [userId]
       );

       if (matchResult.rows.length === 0) {
         return res.json({
           success: true,
           active: true,
           status: 'searching',
           match: null,
         });
       }

       const match = matchResult.rows[0];

       // Resolve photo URL using resolvePhotoUrl from ../utils/r2-client
       let photoUrl: string | null = null;
       if (match.photo_url && match.photo_url !== '') {
         try {
           photoUrl = await resolvePhotoUrl(match.photo_url);
         } catch (err) {
           logger.warn('Failed to resolve match photo URL', { matchId: match.id });
         }
       }

       // Calculate distance from user's session to match's session
       const userSession = sessionResult.rows[0];
       const distanceKm = calculateHaversineDistance(
         userSession.fuzzed_latitude,
         userSession.fuzzed_longitude,
         match.fuzzed_latitude,
         match.fuzzed_longitude
       );

       // Calculate auto-decline time (5 minutes from match creation, or match expiry, whichever is sooner)
       const autoDeclineAt = new Date(Math.min(
         new Date(match.created_at).getTime() + 5 * 60 * 1000,
         new Date(match.expires_at).getTime()
       ));

       res.json({
         success: true,
         active: true,
         status: 'matched',
         match: {
           id: match.id,
           expiresAt: match.expires_at,
           autoDeclineAt,
           profile: {
             name: match.name,
             age: match.age,
             photoUrl,
             description: match.description,
             distanceKm: Math.round(distanceKm * 10) / 10, // 1 decimal place
           },
         },
       });
     } catch (error: any) {
       logger.error('Failed to get current match', { error: error.message, userId });
       res.status(500).json({ success: false, error: 'Failed to get match status' });
     }
   });
   ```

4. **GET /nearby/count - Get active user count nearby:**
   ```typescript
   /**
    * GET /nearby/count - Get count of active users nearby
    *
    * Returns count of active After Hours sessions within user's max distance preference.
    * Used for social proof ("12 people nearby in After Hours").
    */
   router.get('/nearby/count', async (req: Request, res: Response) => {
     const userId = req.user!.userId;

     try {
       // Get user's session and preferences
       const sessionResult = await pool.query(
         `SELECT s.fuzzed_latitude, s.fuzzed_longitude, p.max_distance_km
          FROM after_hours_sessions s
          JOIN after_hours_preferences p ON p.user_id = s.user_id
          WHERE s.user_id = $1 AND s.ended_at IS NULL`,
         [userId]
       );

       if (sessionResult.rows.length === 0) {
         return res.status(400).json({
           success: false,
           error: 'No active session',
           code: 'NO_ACTIVE_SESSION',
         });
       }

       const { fuzzed_latitude, fuzzed_longitude, max_distance_km } = sessionResult.rows[0];

       const count = await getActiveUserCountNearby(
         pool,
         { lat: fuzzed_latitude, lng: fuzzed_longitude },
         max_distance_km
       );

       res.json({
         success: true,
         count: count - 1, // Exclude self from count
         maxDistanceKm: max_distance_km,
       });
     } catch (error: any) {
       logger.error('Failed to get nearby count', { error: error.message, userId });
       res.status(500).json({ success: false, error: 'Failed to get nearby count' });
     }
   });
   ```

5. **Add helper function at top of file (after imports):**
   ```typescript
   /**
    * Calculate Haversine distance between two points in km
    */
   function calculateHaversineDistance(
     lat1: number, lon1: number,
     lat2: number, lon2: number
   ): number {
     const R = 6371; // Earth radius in km
     const dLat = (lat2 - lat1) * Math.PI / 180;
     const dLon = (lon2 - lon1) * Math.PI / 180;
     const a =
       Math.sin(dLat / 2) * Math.sin(dLat / 2) +
       Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
       Math.sin(dLon / 2) * Math.sin(dLon / 2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
     return R * c;
   }
   ```
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Endpoints are accessible via curl or API testing (if dev server running).
  </verify>
  <done>POST /match/decline, GET /match/current, and GET /nearby/count endpoints exist with correct logic.</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. validateDecline is exported from after-hours-validation.ts
3. POST /match/decline records decline with 3-session memory and triggers matching
4. GET /match/current returns match or searching status
5. GET /nearby/count returns active user count within distance
</verification>

<success_criteria>
- Decline endpoint updates after_hours_declines with UPSERT pattern
- Decline endpoint marks match with declined_by and declined_at
- Decline triggers matching after 30-second cooldown
- Current match endpoint resolves photo URL (using resolvePhotoUrl from ../utils/r2-client)
- Current match endpoint calculates distance
- Nearby count endpoint uses Haversine distance filter
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-matching-engine/03-03-SUMMARY.md`
</output>
