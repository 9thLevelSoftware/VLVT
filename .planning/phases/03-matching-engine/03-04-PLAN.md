---
phase: 03-matching-engine
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - backend/profile-service/src/services/matching-scheduler.ts
  - backend/profile-service/src/routes/after-hours.ts
autonomous: true

must_haves:
  truths:
    - "Auto-decline fires after 5 minutes if user doesn't respond to match"
    - "Expired matches are cleaned up and users re-enter matching pool"
    - "Match expiry respects both session expiries"
  artifacts:
    - path: "backend/profile-service/src/services/matching-scheduler.ts"
      provides: "Auto-decline job scheduling"
      contains: "auto-decline"
  key_links:
    - from: "matching-scheduler.ts"
      to: "after_hours_matches"
      via: "Update match on auto-decline"
      pattern: "declined_by.*system"
---

<objective>
Implement match auto-decline timer and match expiry handling.

Purpose: From CONTEXT.md: "Hard timer on match card - auto-decline after X minutes if no decision". Users who don't respond within 5 minutes have their match auto-declined, freeing both users to receive new matches. This prevents matches from hanging indefinitely.

Output: Auto-decline job scheduling in matching-scheduler.ts, expiry handling logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-matching-engine/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-decline job scheduling to matching-scheduler.ts</name>
  <files>backend/profile-service/src/services/matching-scheduler.ts</files>
  <action>
Extend matching-scheduler.ts with auto-decline functionality:

1. **Add auto-decline job handling in the worker:**
   In the Worker callback, add a case for `auto-decline-match`:
   ```typescript
   else if (job.name === 'auto-decline-match') {
     await handleAutoDeclineMatch(pool, io, job.data.matchId);
   }
   ```

2. **Add handleAutoDeclineMatch function:**
   ```typescript
   /**
    * Handle auto-decline when match timer expires
    * Marks match as declined by 'system' and triggers matching for both users
    */
   async function handleAutoDeclineMatch(
     pool: Pool,
     io: Server,
     matchId: string
   ): Promise<void> {
     logger.info('Processing auto-decline for match', { matchId });

     // Get match details (only if not already declined)
     const matchResult = await pool.query(
       `SELECT id, user_id_1, user_id_2, session_id
        FROM after_hours_matches
        WHERE id = $1 AND declined_by IS NULL`,
       [matchId]
     );

     if (matchResult.rows.length === 0) {
       logger.info('Match already declined or not found, skipping auto-decline', { matchId });
       return;
     }

     const match = matchResult.rows[0];

     // Mark as auto-declined by system
     await pool.query(
       `UPDATE after_hours_matches
        SET declined_by = 'system', declined_at = NOW()
        WHERE id = $1`,
       [matchId]
     );

     logger.info('Match auto-declined', {
       matchId,
       user1: match.user_id_1,
       user2: match.user_id_2,
     });

     // Notify both users that match expired
     io.to(`user:${match.user_id_1}`).emit('after_hours:match_expired', {
       matchId,
       reason: 'timeout',
     });
     io.to(`user:${match.user_id_2}`).emit('after_hours:match_expired', {
       matchId,
       reason: 'timeout',
     });

     // Get both users' active sessions and trigger matching for each
     const sessions = await pool.query(
       `SELECT id, user_id FROM after_hours_sessions
        WHERE user_id IN ($1, $2) AND ended_at IS NULL`,
       [match.user_id_1, match.user_id_2]
     );

     for (const session of sessions.rows) {
       // Trigger matching immediately (no cooldown for auto-decline)
       triggerMatchingForUser(session.user_id, session.id, 5000).catch((err) => {
         logger.error('Failed to trigger matching after auto-decline', {
           userId: session.user_id,
           error: err.message,
         });
       });
     }
   }
   ```

3. **Add scheduleAutoDecline function (exported):**
   ```typescript
   /**
    * Schedule auto-decline for a match after 5 minutes
    * Called when match is created
    */
   export async function scheduleAutoDecline(
     matchId: string,
     delayMs: number = 5 * 60 * 1000 // 5 minutes default
   ): Promise<void> {
     if (!matchingQueue) {
       logger.warn('Cannot schedule auto-decline: matching scheduler not initialized');
       return;
     }

     await matchingQueue.add(
       'auto-decline-match',
       { matchId },
       {
         delay: delayMs,
         jobId: `auto-decline:${matchId}`,
         removeOnComplete: true,
         removeOnFail: 10,
       }
     );

     logger.info('Scheduled auto-decline for match', {
       matchId,
       delayMs,
       willDeclineAt: new Date(Date.now() + delayMs).toISOString(),
     });
   }
   ```

4. **Add cancelAutoDecline function (exported):**
   ```typescript
   /**
    * Cancel auto-decline when user manually declines or match is saved
    */
   export async function cancelAutoDecline(matchId: string): Promise<void> {
     if (!matchingQueue) {
       logger.warn('Cannot cancel auto-decline: matching scheduler not initialized');
       return;
     }

     const jobId = `auto-decline:${matchId}`;
     const job = await matchingQueue.getJob(jobId);

     if (job) {
       await job.remove();
       logger.info('Cancelled auto-decline job', { matchId, jobId });
     }
   }
   ```

5. **Update deliverMatchToBothUsers to schedule auto-decline:**
   After creating the match and before emitting events, add:
   ```typescript
   // Schedule auto-decline after 5 minutes
   await scheduleAutoDecline(match.id);
   ```

6. **Export new functions:**
   Add `scheduleAutoDecline` and `cancelAutoDecline` to exports.
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
New exports are accessible: scheduleAutoDecline, cancelAutoDecline
  </verify>
  <done>Auto-decline job scheduled when match created, fires after 5 minutes, notifies both users and triggers re-matching.</done>
</task>

<task type="auto">
  <name>Task 2: Cancel auto-decline when user manually declines</name>
  <files>backend/profile-service/src/routes/after-hours.ts</files>
  <action>
Update the POST /match/decline endpoint to cancel the auto-decline job:

1. **Add import:**
   ```typescript
   import { triggerMatchingForUser, cancelAutoDecline } from '../services/matching-scheduler';
   ```
   (Update existing import if triggerMatchingForUser is already imported)

2. **In POST /match/decline, after marking match as declined:**
   After the `UPDATE after_hours_matches SET declined_by...` query, add:
   ```typescript
   // Cancel the auto-decline job since user manually declined
   cancelAutoDecline(matchId).catch((err) => {
     logger.error('Failed to cancel auto-decline', { matchId, error: err.message });
   });
   ```

This ensures we don't waste resources on a job that's no longer needed.
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Decline endpoint imports and calls cancelAutoDecline.
  </verify>
  <done>Manual decline cancels the auto-decline job.</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. scheduleAutoDecline and cancelAutoDecline are exported from matching-scheduler.ts
3. Match creation schedules auto-decline after 5 minutes
4. Manual decline cancels the auto-decline job
5. Auto-decline notifies both users and triggers re-matching
</verification>

<success_criteria>
- Auto-decline job fires 5 minutes after match creation
- Auto-decline marks match with declined_by='system'
- Both users receive after_hours:match_expired event
- Both users re-enter matching pool immediately after auto-decline
- Manual decline cancels the scheduled auto-decline
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-matching-engine/03-04-SUMMARY.md`
</output>
