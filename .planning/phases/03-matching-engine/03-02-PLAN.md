---
phase: 03-matching-engine
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/profile-service/src/services/matching-scheduler.ts
  - backend/profile-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Matching job runs periodically (every 30 seconds) for all active sessions"
    - "Matching triggers on session start with 15-second delay"
    - "Matching triggers on decline with 30-second cooldown"
    - "Match is delivered to both users via Socket.IO event"
  artifacts:
    - path: "backend/profile-service/src/services/matching-scheduler.ts"
      provides: "BullMQ scheduler for periodic and event-driven matching"
      exports: ["initializeMatchingScheduler", "triggerMatchingForUser", "closeMatchingScheduler"]
  key_links:
    - from: "matching-scheduler.ts"
      to: "matching-engine.ts"
      via: "Import and call findMatchCandidate, createAfterHoursMatch"
      pattern: "findMatchCandidate"
    - from: "matching-scheduler.ts"
      to: "Socket.IO"
      via: "io.to() emit for match delivery"
      pattern: "emit.*after_hours"
    - from: "index.ts"
      to: "matching-scheduler.ts"
      via: "Initialize on startup"
      pattern: "initializeMatchingScheduler"
---

<objective>
Create the BullMQ job scheduler for matching: periodic fallback (every 30s) and event-driven triggers (session start, decline).

Purpose: The matching scheduler coordinates when matching runs. It combines periodic sweeps (catch users who might have been missed) with event-driven triggers (immediate matching when user joins or declines). Matches are delivered via Socket.IO for real-time experience.

Output: matching-scheduler.ts service with BullMQ queue/worker, integrated into server startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-matching-engine/03-RESEARCH.md

# Existing patterns
@backend/profile-service/src/services/session-scheduler.ts
@backend/profile-service/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create matching-scheduler.ts with BullMQ periodic and event-driven matching</name>
  <files>backend/profile-service/src/services/matching-scheduler.ts</files>
  <action>
Create the matching scheduler service following session-scheduler.ts patterns:

1. **Constants and module-level state:**
   ```typescript
   const QUEUE_NAME = 'after-hours-matching';
   let matchingQueue: Queue | null = null;
   let matchingWorker: Worker | null = null;
   ```

2. **initializeMatchingScheduler function:**
   - Takes: pool: Pool, io: Server (Socket.IO server instance)
   - Creates Redis connection (same pattern as session-scheduler.ts)
   - Creates BullMQ Queue
   - Sets up periodic job scheduler using `upsertJobScheduler`:
     ```typescript
     await matchingQueue.upsertJobScheduler(
       'periodic-matching',
       { every: 30000 }, // 30 seconds
       { name: 'run-matching-cycle', data: {} }
     );
     ```
   - Creates Worker to handle jobs:
     - `run-matching-cycle`: Call `runMatchingCycleForAllSessions(pool, io)`
     - `match-single-user`: Call `runMatchingForUser(pool, io, job.data.userId, job.data.sessionId)`
   - Worker error/completion event handlers following session-scheduler.ts pattern

3. **runMatchingCycleForAllSessions function (internal):**
   - Query all active sessions: `SELECT id, user_id, fuzzed_latitude, fuzzed_longitude FROM after_hours_sessions WHERE ended_at IS NULL AND expires_at > NOW() + INTERVAL '2 minutes'`
   - For each session without an active match:
     a. Check if user already has undeclined match: query after_hours_matches
     b. If no active match, call runMatchingForUser

4. **runMatchingForUser function (internal):**
   - Takes: pool, io, userId, sessionId
   - Get user's preferences from after_hours_preferences
   - Get user's session location from after_hours_sessions
   - Get user's gender from profiles
   - Call `findMatchCandidate` from matching-engine.ts
   - If candidate found:
     a. Call `createAfterHoursMatch` - if returns null (lock failed), try next candidate or skip
     b. If match created, call `deliverMatchToBothUsers(io, pool, match)`
   - If no candidate found:
     a. Emit `after_hours:no_matches` to user's room with active user count (from getActiveUserCountNearby)

5. **deliverMatchToBothUsers function (internal):**
   - For each user in the match:
     a. Get the OTHER user's profile info (name, age, photo, description, distance)
     b. Resolve photo URL to presigned URL using existing resolvePhotoUrl
     c. Build match card object with 5-minute auto-decline timer
     d. Emit `after_hours:match` to `user:${userId}` room
   - Log match delivery

6. **triggerMatchingForUser function (exported):**
   - Takes: userId, sessionId, delayMs (default 15000 for session start, 30000 for decline)
   - Adds `match-single-user` job to queue with specified delay
   - Job ID includes timestamp to allow multiple triggers: `match:user:${userId}:${Date.now()}`
   - removeOnComplete: true, removeOnFail: 10

7. **closeMatchingScheduler function (exported):**
   - Clean shutdown following session-scheduler.ts pattern

IMPORTANT:
- Import findMatchCandidate, createAfterHoursMatch, getActiveUserCountNearby from ./matching-engine
- Import resolvePhotoUrl from ../utils/r2-client
- Import logger from ../utils/logger
- Use non-blocking init pattern (don't crash server if Redis unavailable)
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Exports accessible: initializeMatchingScheduler, triggerMatchingForUser, closeMatchingScheduler
  </verify>
  <done>matching-scheduler.ts exists with periodic job scheduler (30s), event-driven triggers, and Socket.IO match delivery.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching scheduler into server startup</name>
  <files>backend/profile-service/src/index.ts</files>
  <action>
Modify index.ts to initialize matching scheduler alongside session scheduler:

1. **Add import:**
   ```typescript
   import {
     initializeMatchingScheduler,
     closeMatchingScheduler,
   } from './services/matching-scheduler';
   ```

2. **In the startup section (after session scheduler init):**
   Add matching scheduler initialization. Look for where `initializeSessionWorker(pool)` is called and add matching scheduler init after it:
   ```typescript
   // Initialize matching scheduler (requires Socket.IO server)
   // Note: This needs the io server instance, which may require restructuring
   // For now, if io doesn't exist in this file, create a simple HTTP server + Socket.IO
   initializeMatchingScheduler(pool, io).catch((err) => {
     logger.error('Failed to initialize matching scheduler', { error: err.message });
     logger.warn('Matching will not work automatically. Start Redis and restart.');
   });
   ```

   **IMPORTANT:** Check if Socket.IO server exists in index.ts. If not, this plan will document that chat-service handles Socket.IO and matching notifications should be sent via internal HTTP call or shared Redis pub/sub. In that case:
   - Skip the io parameter for now
   - Add TODO comment for Phase 4 to wire up real-time delivery via chat-service

3. **In shutdown handlers (SIGTERM/SIGINT):**
   Add matching scheduler cleanup:
   ```typescript
   // In the graceful shutdown section
   await closeMatchingScheduler();
   ```

4. **Update session start endpoint to trigger matching:**
   Find `POST /session/start` in after-hours.ts and add after successful session creation:
   ```typescript
   // Trigger matching after 15-second delay
   triggerMatchingForUser(userId, session.id, 15000).catch((err) => {
     logger.error('Failed to trigger matching after session start', { error: err.message });
   });
   ```

   This requires adding import in after-hours.ts:
   ```typescript
   import { triggerMatchingForUser } from '../services/matching-scheduler';
   ```
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Server starts without crashing (test with `npm run dev` briefly, then Ctrl+C)
  </verify>
  <done>Matching scheduler initializes on server startup, shuts down gracefully, and session start triggers matching with 15s delay.</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. matching-scheduler.ts exports initializeMatchingScheduler, triggerMatchingForUser, closeMatchingScheduler
3. index.ts imports and initializes matching scheduler
4. Session start endpoint triggers matching
</verification>

<success_criteria>
- BullMQ periodic job runs every 30 seconds
- Session start triggers matching after 15-second delay
- Socket.IO events emit `after_hours:match` to matched users
- Server starts and shuts down cleanly
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-matching-engine/03-02-SUMMARY.md`
</output>
