---
phase: 03-matching-engine
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/profile-service/src/services/matching-scheduler.ts
  - backend/profile-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Matching job runs periodically (every 30 seconds) for all active sessions"
    - "Matching triggers on session start with 15-second delay"
    - "Matching triggers on decline with 30-second cooldown"
    - "Match events are published to Redis for chat-service consumption"
  artifacts:
    - path: "backend/profile-service/src/services/matching-scheduler.ts"
      provides: "BullMQ scheduler for periodic and event-driven matching"
      exports: ["initializeMatchingScheduler", "triggerMatchingForUser", "closeMatchingScheduler", "publishMatchEvent"]
  key_links:
    - from: "matching-scheduler.ts"
      to: "matching-engine.ts"
      via: "Import and call findMatchCandidate, createAfterHoursMatch"
      pattern: "findMatchCandidate"
    - from: "matching-scheduler.ts"
      to: "Redis pub/sub"
      via: "Publish match events to after_hours:events channel"
      pattern: "publish.*after_hours:events"
    - from: "index.ts"
      to: "matching-scheduler.ts"
      via: "Initialize on startup"
      pattern: "initializeMatchingScheduler"
---

<objective>
Create the BullMQ job scheduler for matching: periodic fallback (every 30s) and event-driven triggers (session start, decline).

Purpose: The matching scheduler coordinates when matching runs. It combines periodic sweeps (catch users who might have been missed) with event-driven triggers (immediate matching when user joins or declines). Match events are published to Redis pub/sub for chat-service to deliver via its Socket.IO connection.

Output: matching-scheduler.ts service with BullMQ queue/worker, Redis pub/sub for events, integrated into server startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-matching-engine/03-RESEARCH.md

# Existing patterns
@backend/profile-service/src/services/session-scheduler.ts
@backend/profile-service/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create matching-scheduler.ts with BullMQ periodic and event-driven matching</name>
  <files>backend/profile-service/src/services/matching-scheduler.ts</files>
  <action>
Create the matching scheduler service following session-scheduler.ts patterns:

1. **Constants and module-level state:**
   ```typescript
   const QUEUE_NAME = 'after-hours-matching';
   const REDIS_EVENTS_CHANNEL = 'after_hours:events';
   let matchingQueue: Queue | null = null;
   let matchingWorker: Worker | null = null;
   let redisPublisher: Redis | null = null;  // Separate Redis client for pub/sub
   ```

2. **initializeMatchingScheduler function:**
   - Takes: pool: Pool (NO Socket.IO - profile-service doesn't have it)
   - Creates Redis connection (same pattern as session-scheduler.ts)
   - Creates SEPARATE Redis client for pub/sub publishing (BullMQ uses its own connection)
   - Creates BullMQ Queue
   - Sets up periodic job scheduler using `upsertJobScheduler`:
     ```typescript
     await matchingQueue.upsertJobScheduler(
       'periodic-matching',
       { every: 30000 }, // 30 seconds
       { name: 'run-matching-cycle', data: {} }
     );
     ```
   - Creates Worker to handle jobs:
     - `run-matching-cycle`: Call `runMatchingCycleForAllSessions(pool)`
     - `match-single-user`: Call `runMatchingForUser(pool, job.data.userId, job.data.sessionId)`
   - Worker error/completion event handlers following session-scheduler.ts pattern

3. **runMatchingCycleForAllSessions function (internal):**
   - Query all active sessions: `SELECT id, user_id, fuzzed_latitude, fuzzed_longitude FROM after_hours_sessions WHERE ended_at IS NULL AND expires_at > NOW() + INTERVAL '2 minutes'`
   - For each session without an active match:
     a. Check if user already has undeclined match: query after_hours_matches
     b. If no active match, call runMatchingForUser

4. **runMatchingForUser function (internal):**
   - Takes: pool, userId, sessionId
   - Get user's preferences from after_hours_preferences
   - Get user's session location from after_hours_sessions
   - Get user's gender from profiles
   - Call `findMatchCandidate` from matching-engine.ts
   - If candidate found:
     a. Call `createAfterHoursMatch` - if returns null (lock failed), try next candidate or skip
     b. If match created, call `publishMatchToBothUsers(pool, match)`
   - If no candidate found:
     a. Publish `after_hours:no_matches` event via Redis with active user count

5. **publishMatchToBothUsers function (internal):**
   - For each user in the match:
     a. Get the OTHER user's profile info (name, age, photo, description, distance)
     b. Resolve photo URL to presigned URL using resolvePhotoUrl from ../utils/r2-client
     c. Build match card object with 5-minute auto-decline timer
     d. Publish to Redis channel `after_hours:events` with structure:
        ```typescript
        {
          type: 'after_hours:match',
          targetUserId: userId,
          payload: { matchId, expiresAt, autoDeclineAt, profile: {...} }
        }
        ```
   - Log match event published
   - NOTE: chat-service will subscribe to this channel and deliver to connected clients via Socket.IO (Phase 4)

6. **publishMatchEvent function (exported helper):**
   ```typescript
   export async function publishMatchEvent(
     eventType: string,
     targetUserId: string,
     payload: Record<string, any>
   ): Promise<void> {
     if (!redisPublisher) {
       logger.warn('Cannot publish event: Redis publisher not initialized');
       return;
     }
     await redisPublisher.publish(REDIS_EVENTS_CHANNEL, JSON.stringify({
       type: eventType,
       targetUserId,
       payload,
       timestamp: new Date().toISOString()
     }));
   }
   ```

7. **triggerMatchingForUser function (exported):**
   - Takes: userId, sessionId, delayMs (default 15000 for session start, 30000 for decline)
   - Adds `match-single-user` job to queue with specified delay
   - Job ID includes timestamp to allow multiple triggers: `match:user:${userId}:${Date.now()}`
   - removeOnComplete: true, removeOnFail: 10

8. **closeMatchingScheduler function (exported):**
   - Clean shutdown following session-scheduler.ts pattern
   - Also close redisPublisher connection

IMPORTANT:
- Import findMatchCandidate, createAfterHoursMatch, getActiveUserCountNearby from ./matching-engine
- Import resolvePhotoUrl from ../utils/r2-client
- Import logger from ../utils/logger
- Import Redis from ioredis (for pub/sub client)
- Use non-blocking init pattern (don't crash server if Redis unavailable)
- NO Socket.IO - profile-service doesn't have it. Use Redis pub/sub instead.
- Document that chat-service will subscribe to `after_hours:events` channel in Phase 4
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Exports accessible: initializeMatchingScheduler, triggerMatchingForUser, closeMatchingScheduler, publishMatchEvent
  </verify>
  <done>matching-scheduler.ts exists with periodic job scheduler (30s), event-driven triggers, and Redis pub/sub for match delivery (chat-service consumes in Phase 4).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching scheduler into server startup</name>
  <files>backend/profile-service/src/index.ts</files>
  <action>
Modify index.ts to initialize matching scheduler alongside session scheduler:

1. **Add import:**
   ```typescript
   import {
     initializeMatchingScheduler,
     closeMatchingScheduler,
   } from './services/matching-scheduler';
   ```

2. **In the startup section (after session scheduler init):**
   Add matching scheduler initialization. Look for where `initializeSessionWorker(pool)` is called and add matching scheduler init after it:
   ```typescript
   // Initialize matching scheduler (uses Redis pub/sub for event delivery)
   // Note: Match events are published to Redis channel 'after_hours:events'
   // chat-service subscribes to this channel and delivers to clients via Socket.IO
   initializeMatchingScheduler(pool).catch((err) => {
     logger.error('Failed to initialize matching scheduler', { error: err.message });
     logger.warn('Matching will not work automatically. Start Redis and restart.');
   });
   ```

3. **In shutdown handlers (SIGTERM/SIGINT):**
   Add matching scheduler cleanup:
   ```typescript
   // In the graceful shutdown section
   await closeMatchingScheduler();
   ```

4. **Update session start endpoint to trigger matching:**
   Find `POST /session/start` in after-hours.ts and add after successful session creation:
   ```typescript
   // Trigger matching after 15-second delay
   triggerMatchingForUser(userId, session.id, 15000).catch((err) => {
     logger.error('Failed to trigger matching after session start', { error: err.message });
   });
   ```

   This requires adding import in after-hours.ts:
   ```typescript
   import { triggerMatchingForUser } from '../services/matching-scheduler';
   ```
  </action>
  <verify>
TypeScript compiles: `cd backend/profile-service && npm run build`
Server starts without crashing (test with `npm run dev` briefly, then Ctrl+C)
  </verify>
  <done>Matching scheduler initializes on server startup, shuts down gracefully, and session start triggers matching with 15s delay.</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. matching-scheduler.ts exports initializeMatchingScheduler, triggerMatchingForUser, closeMatchingScheduler, publishMatchEvent
3. index.ts imports and initializes matching scheduler (no Socket.IO dependency)
4. Session start endpoint triggers matching
5. Match events are published to Redis channel `after_hours:events`
</verification>

<success_criteria>
- BullMQ periodic job runs every 30 seconds
- Session start triggers matching after 15-second delay
- Match events published to Redis `after_hours:events` channel (NOT Socket.IO directly)
- Server starts and shuts down cleanly
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-matching-engine/03-02-SUMMARY.md`
</output>
