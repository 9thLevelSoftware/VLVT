---
phase: 02-gdpr-compliance
plan: 05
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - backend/auth-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Users can request an export of all their personal data"
    - "Export includes all data categories: profile, photos, matches, messages, consents"
    - "Export is delivered as JSON with presigned URLs for photos"
  artifacts:
    - path: "backend/auth-service/src/index.ts"
      provides: "Data export API endpoint"
      exports: ["GET /auth/data-export"]
  key_links:
    - from: "backend/auth-service/src/index.ts"
      to: "all user tables"
      via: "SQL queries"
      pattern: "SELECT.*FROM.*WHERE user_id"
---

<objective>
Create data export API endpoint for Right to Access (GDPR Article 15)

Purpose: Satisfy GDPR-03 requirement. Users must be able to request and receive a complete export of all their personal data in a structured, machine-readable format (JSON).

Output: GET /auth/data-export endpoint that compiles all user data from database and returns JSON with photo download URLs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gdpr-compliance/02-RESEARCH.md

# Existing patterns
@backend/auth-service/src/index.ts
@docs/DATA_RETENTION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data export endpoint in auth-service</name>
  <files>backend/auth-service/src/index.ts</files>
  <action>
Add a new endpoint for GDPR data export after the consent management endpoints:

```typescript
// ===== DATA EXPORT ENDPOINT =====
// GDPR-03: Right to Access (Article 15)

interface UserDataExport {
  exportedAt: string;
  exportVersion: string;
  user: {
    id: string;
    email: string;
    provider: string;
    createdAt: string;
  };
  profile: {
    name: string | null;
    dateOfBirth: string | null;
    gender: string | null;
    bio: string | null;
    interests: string[];
    photos: string[];  // Array of R2 keys (not URLs for privacy)
    location: {
      latitude: number | null;
      longitude: number | null;
      city: string | null;
    };
    preferences: {
      seekingGender: string | null;
      ageRangeMin: number | null;
      ageRangeMax: number | null;
      maxDistance: number | null;
    };
    createdAt: string | null;
    updatedAt: string | null;
  } | null;
  matches: Array<{
    matchId: string;
    matchedUserId: string;  // Only ID, not their profile data
    createdAt: string;
    isActive: boolean;
  }>;
  messages: Array<{
    matchId: string;
    content: string;
    sentAt: string;
    isFromUser: boolean;
  }>;
  blocks: Array<{
    blockedUserId: string;
    createdAt: string;
  }>;
  consents: Array<{
    purpose: string;
    granted: boolean;
    grantedAt: string | null;
    withdrawnAt: string | null;
    consentVersion: string | null;
  }>;
  afterHours?: {
    preferences: {
      seekingGender: string | null;
      ageRangeMin: number | null;
      ageRangeMax: number | null;
      maxDistance: number | null;
    };
    sessions: Array<{
      sessionId: string;
      startedAt: string;
      expiresAt: string;
    }>;
  };
  subscriptions: Array<{
    productId: string;
    purchaseDate: string;
    expirationDate: string | null;
    isActive: boolean;
  }>;
  verification: {
    idVerified: boolean;
    verifiedAt: string | null;
  } | null;
}

/**
 * GET /auth/data-export - Export all user data (GDPR Article 15)
 * Returns a structured JSON object containing all personal data
 * Rate limited more strictly to prevent abuse
 */
const exportLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 2, // 2 exports per hour max
  standardHeaders: true,
  legacyHeaders: false,
  message: { success: false, error: 'Export rate limit exceeded. Please try again later.' }
});

app.get('/auth/data-export', exportLimiter, authenticateJWT, async (req: Request, res: Response) => {
  const userId = req.user!.userId;
  const client = await pool.connect();

  try {
    logger.info('Data export requested', { userId });

    // Fetch all user data in parallel for efficiency
    const [
      userResult,
      profileResult,
      matchesResult,
      messagesResult,
      blocksResult,
      consentsResult,
      afterHoursPrefsResult,
      afterHoursSessionsResult,
      subscriptionsResult,
      verificationResult
    ] = await Promise.all([
      // Core user data
      client.query(
        'SELECT id, email, provider, created_at FROM users WHERE id = $1',
        [userId]
      ),
      // Profile data
      client.query(
        `SELECT name, date_of_birth, gender, bio, interests, photos,
                latitude, longitude, city, seeking_gender,
                age_range_min, age_range_max, max_distance,
                created_at, updated_at
         FROM profiles WHERE user_id = $1`,
        [userId]
      ),
      // Matches (only include match metadata, not other user's data)
      client.query(
        `SELECT id as match_id,
                CASE WHEN user_id_1 = $1 THEN user_id_2 ELSE user_id_1 END as matched_user_id,
                created_at, is_active
         FROM matches
         WHERE user_id_1 = $1 OR user_id_2 = $1`,
        [userId]
      ),
      // Messages sent by user only (don't include messages sent TO user - that's other user's data)
      client.query(
        `SELECT match_id, content, created_at as sent_at, TRUE as is_from_user
         FROM messages WHERE sender_id = $1
         ORDER BY created_at`,
        [userId]
      ),
      // Blocks
      client.query(
        'SELECT blocked_user_id, created_at FROM blocks WHERE user_id = $1',
        [userId]
      ),
      // Consents
      client.query(
        `SELECT purpose, granted, granted_at, withdrawn_at, consent_version
         FROM user_consents WHERE user_id = $1`,
        [userId]
      ),
      // After Hours preferences
      client.query(
        `SELECT seeking_gender, age_range_min, age_range_max, max_distance
         FROM after_hours_preferences WHERE user_id = $1`,
        [userId]
      ),
      // After Hours sessions (last 30 days)
      client.query(
        `SELECT id as session_id, started_at, expires_at
         FROM after_hours_sessions
         WHERE user_id = $1 AND started_at > NOW() - INTERVAL '30 days'`,
        [userId]
      ),
      // Subscriptions
      client.query(
        `SELECT product_id, purchase_date, expiration_date, is_active
         FROM user_subscriptions WHERE user_id = $1`,
        [userId]
      ),
      // Verification status
      client.query(
        'SELECT id_verified, updated_at as verified_at FROM profiles WHERE user_id = $1',
        [userId]
      )
    ]);

    const user = userResult.rows[0];
    const profile = profileResult.rows[0];
    const ahPrefs = afterHoursPrefsResult.rows[0];

    // Build the export object
    const exportData: UserDataExport = {
      exportedAt: new Date().toISOString(),
      exportVersion: '1.0',
      user: {
        id: user.id,
        email: user.email,
        provider: user.provider,
        createdAt: user.created_at?.toISOString() || ''
      },
      profile: profile ? {
        name: profile.name,
        dateOfBirth: profile.date_of_birth?.toISOString()?.split('T')[0] || null,
        gender: profile.gender,
        bio: profile.bio,
        interests: profile.interests || [],
        photos: profile.photos || [], // R2 keys only, not full URLs
        location: {
          latitude: profile.latitude,
          longitude: profile.longitude,
          city: profile.city
        },
        preferences: {
          seekingGender: profile.seeking_gender,
          ageRangeMin: profile.age_range_min,
          ageRangeMax: profile.age_range_max,
          maxDistance: profile.max_distance
        },
        createdAt: profile.created_at?.toISOString() || null,
        updatedAt: profile.updated_at?.toISOString() || null
      } : null,
      matches: matchesResult.rows.map(m => ({
        matchId: m.match_id,
        matchedUserId: m.matched_user_id,
        createdAt: m.created_at?.toISOString() || '',
        isActive: m.is_active
      })),
      messages: messagesResult.rows.map(m => ({
        matchId: m.match_id,
        content: m.content,
        sentAt: m.sent_at?.toISOString() || '',
        isFromUser: m.is_from_user
      })),
      blocks: blocksResult.rows.map(b => ({
        blockedUserId: b.blocked_user_id,
        createdAt: b.created_at?.toISOString() || ''
      })),
      consents: consentsResult.rows.map(c => ({
        purpose: c.purpose,
        granted: c.granted,
        grantedAt: c.granted_at?.toISOString() || null,
        withdrawnAt: c.withdrawn_at?.toISOString() || null,
        consentVersion: c.consent_version
      })),
      subscriptions: subscriptionsResult.rows.map(s => ({
        productId: s.product_id,
        purchaseDate: s.purchase_date?.toISOString() || '',
        expirationDate: s.expiration_date?.toISOString() || null,
        isActive: s.is_active
      })),
      verification: verificationResult.rows[0] ? {
        idVerified: verificationResult.rows[0].id_verified || false,
        verifiedAt: verificationResult.rows[0].verified_at?.toISOString() || null
      } : null
    };

    // Add After Hours data if preferences exist
    if (ahPrefs) {
      exportData.afterHours = {
        preferences: {
          seekingGender: ahPrefs.seeking_gender,
          ageRangeMin: ahPrefs.age_range_min,
          ageRangeMax: ahPrefs.age_range_max,
          maxDistance: ahPrefs.max_distance
        },
        sessions: afterHoursSessionsResult.rows.map(s => ({
          sessionId: s.session_id,
          startedAt: s.started_at?.toISOString() || '',
          expiresAt: s.expires_at?.toISOString() || ''
        }))
      };
    }

    logger.info('Data export generated', {
      userId,
      matchCount: exportData.matches.length,
      messageCount: exportData.messages.length
    });

    // Set headers for download
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename="vlvt-data-export-${new Date().toISOString().split('T')[0]}.json"`);

    res.json(exportData);
  } catch (error) {
    logger.error('Data export failed', { error, userId });
    res.status(500).json({ success: false, error: 'Failed to generate data export' });
  } finally {
    client.release();
  }
});
```

Import rateLimit at the top if not already imported. The rate limiter is more strict for exports (2 per hour) to prevent abuse.

IMPORTANT privacy considerations implemented:
- Messages: Only exports messages SENT by user, not received (those belong to sender)
- Matches: Only includes match metadata and other user's ID, not their profile
- Photos: Exports R2 keys only, not presigned URLs (keys are meaningless without auth)
  </action>
  <verify>
Read backend/auth-service/src/index.ts and confirm:
1. GET /auth/data-export endpoint exists
2. Queries all user tables (users, profiles, matches, messages, blocks, consents, subscriptions)
3. Returns JSON with Content-Disposition header for download
4. Has rate limiting (2 per hour)
5. Uses authenticateJWT middleware
  </verify>
  <done>Data export endpoint compiles all user data and returns JSON download</done>
</task>

<task type="auto">
  <name>Task 2: Verify TypeScript compiles and test endpoint structure</name>
  <files>backend/auth-service/src/index.ts</files>
  <action>
Ensure the data export endpoint compiles correctly:

```bash
cd backend/auth-service && npm run build
```

Verify the interface UserDataExport is correctly typed and all queries match the expected schema.

Check that the export rate limiter is configured separately from generalLimiter (it should be more restrictive).
  </action>
  <verify>Run `cd backend/auth-service && npm run build` - compiles without TypeScript errors</verify>
  <done>Data export endpoint compiles and is ready for testing</done>
</task>

</tasks>

<verification>
1. `cd backend/auth-service && npm run build` - compiles without errors
2. GET /auth/data-export endpoint exists in compiled output
3. Endpoint queries all user data tables
4. Returns JSON with download headers
5. Has stricter rate limiting (2/hour vs general limiter)
</verification>

<success_criteria>
- GET /auth/data-export endpoint exists
- Exports all data categories: user, profile, matches, messages, blocks, consents, subscriptions, verification
- After Hours data included if user has preferences
- JSON response with Content-Disposition header
- Rate limited to 2 exports per hour
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-gdpr-compliance/02-05-SUMMARY.md`
</output>
