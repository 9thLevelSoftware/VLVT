---
phase: 02-gdpr-compliance
plan: 03
type: execute
wave: 3
depends_on: ["02-01"]
files_modified:
  - backend/migrations/026_add_user_consents.sql
  - backend/auth-service/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User consents are tracked per purpose (location, marketing, analytics, after_hours)"
    - "Consent records include version, timestamp, and withdrawal timestamp"
    - "Users can grant and withdraw consent via API without deleting account"
  artifacts:
    - path: "backend/migrations/026_add_user_consents.sql"
      provides: "Granular consent tracking table"
      contains: "user_consents"
    - path: "backend/auth-service/src/index.ts"
      provides: "Consent management API endpoints"
      exports: ["GET /auth/consents", "POST /auth/consents", "DELETE /auth/consents/:purpose"]
  key_links:
    - from: "backend/auth-service/src/index.ts"
      to: "user_consents table"
      via: "SQL queries"
      pattern: "user_consents"
---

<objective>
Create consent database infrastructure and API endpoints

Purpose: Satisfy GDPR-02 and GDPR-05 requirements. Users must be able to grant granular consent per purpose (not bundled acceptance) and withdraw consent without deleting their account.

Output: Migration for user_consents table, API endpoints for consent management (list, grant, withdraw).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gdpr-compliance/02-RESEARCH.md

# Existing patterns
@backend/migrations/021_add_after_hours_tables.sql
@backend/auth-service/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user_consents migration</name>
  <files>backend/migrations/026_add_user_consents.sql</files>
  <action>
Create migration 026_add_user_consents.sql following existing migration patterns.

```sql
-- ============================================
-- MIGRATION 026: Add User Consents Table
-- GDPR-02, GDPR-05: Granular consent tracking with withdrawal support
-- ============================================

-- Create enum for consent purposes
CREATE TYPE consent_purpose AS ENUM (
  'location_discovery',    -- Allow location-based profile discovery
  'marketing',             -- Receive marketing communications
  'analytics',             -- Allow analytics data collection
  'after_hours'            -- After Hours mode (special category data)
);

-- Create user_consents table
CREATE TABLE IF NOT EXISTS user_consents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  purpose consent_purpose NOT NULL,
  granted BOOLEAN NOT NULL DEFAULT FALSE,
  granted_at TIMESTAMP WITH TIME ZONE,
  withdrawn_at TIMESTAMP WITH TIME ZONE,
  consent_version TEXT NOT NULL,  -- Links to privacy policy version
  ip_address TEXT,                -- Record IP for audit (optional)
  user_agent TEXT,                -- Record device for audit (optional)
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

  -- Each user can only have one consent record per purpose
  UNIQUE(user_id, purpose)
);

-- Indexes for common queries
CREATE INDEX idx_user_consents_user_id ON user_consents(user_id);
CREATE INDEX idx_user_consents_purpose ON user_consents(purpose);
CREATE INDEX idx_user_consents_granted ON user_consents(granted) WHERE granted = TRUE;

-- Trigger to update updated_at
CREATE TRIGGER update_user_consents_updated_at
  BEFORE UPDATE ON user_consents
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Comments for documentation
COMMENT ON TABLE user_consents IS 'GDPR: Tracks granular consent per purpose with audit trail';
COMMENT ON COLUMN user_consents.consent_version IS 'Privacy policy version at time of consent (e.g., "2026-01-24")';
COMMENT ON COLUMN user_consents.withdrawn_at IS 'When consent was withdrawn (NULL if still granted)';

-- Migrate existing after_hours_consent from users table to new table
-- This preserves existing consent state
INSERT INTO user_consents (user_id, purpose, granted, granted_at, consent_version)
SELECT
  id,
  'after_hours'::consent_purpose,
  after_hours_consent,
  after_hours_consent_at,
  '2026-01-24'  -- Current version at migration time
FROM users
WHERE after_hours_consent IS NOT NULL
ON CONFLICT (user_id, purpose) DO NOTHING;
```

NOTE: The trigger function update_updated_at_column() already exists from previous migrations.
  </action>
  <verify>File exists at backend/migrations/026_add_user_consents.sql with CREATE TABLE user_consents</verify>
  <done>Migration 026 creates user_consents table with granular consent tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add consent management API endpoints to auth-service</name>
  <files>backend/auth-service/src/index.ts</files>
  <action>
Add three new endpoints for consent management after the account deletion endpoint:

```typescript
// ===== CONSENT MANAGEMENT ENDPOINTS =====
// GDPR-02, GDPR-05: Granular consent with withdrawal support

// Current privacy policy version (update when policy changes)
const CURRENT_CONSENT_VERSION = '2026-01-24';

/**
 * GET /auth/consents - Get user's current consent status
 * Returns all consent purposes with their current state
 */
app.get('/auth/consents', generalLimiter, authenticateJWT, async (req: Request, res: Response) => {
  const userId = req.user!.userId;

  try {
    const result = await pool.query(
      `SELECT purpose, granted, granted_at, withdrawn_at, consent_version
       FROM user_consents
       WHERE user_id = $1`,
      [userId]
    );

    // Return all purposes with defaults for missing ones
    const allPurposes = ['location_discovery', 'marketing', 'analytics', 'after_hours'];
    const consents = allPurposes.map(purpose => {
      const existing = result.rows.find(r => r.purpose === purpose);
      return {
        purpose,
        granted: existing?.granted || false,
        grantedAt: existing?.granted_at || null,
        withdrawnAt: existing?.withdrawn_at || null,
        consentVersion: existing?.consent_version || null,
        currentVersion: CURRENT_CONSENT_VERSION,
        needsRenewal: existing?.consent_version && existing.consent_version !== CURRENT_CONSENT_VERSION
      };
    });

    res.json({ success: true, consents, currentVersion: CURRENT_CONSENT_VERSION });
  } catch (error) {
    logger.error('Failed to fetch consents', { error, userId });
    res.status(500).json({ success: false, error: 'Failed to fetch consents' });
  }
});

/**
 * POST /auth/consents - Grant consent for a purpose
 * Body: { purpose: string }
 */
app.post('/auth/consents', generalLimiter, authenticateJWT, async (req: Request, res: Response) => {
  const userId = req.user!.userId;
  const { purpose } = req.body;

  const validPurposes = ['location_discovery', 'marketing', 'analytics', 'after_hours'];
  if (!validPurposes.includes(purpose)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid purpose',
      validPurposes
    });
  }

  try {
    await pool.query(
      `INSERT INTO user_consents (user_id, purpose, granted, granted_at, consent_version, ip_address, user_agent)
       VALUES ($1, $2, TRUE, CURRENT_TIMESTAMP, $3, $4, $5)
       ON CONFLICT (user_id, purpose)
       DO UPDATE SET
         granted = TRUE,
         granted_at = CURRENT_TIMESTAMP,
         withdrawn_at = NULL,
         consent_version = $3,
         ip_address = $4,
         user_agent = $5,
         updated_at = CURRENT_TIMESTAMP`,
      [userId, purpose, CURRENT_CONSENT_VERSION, req.ip, req.headers['user-agent']]
    );

    logger.info('Consent granted', { userId, purpose, version: CURRENT_CONSENT_VERSION });
    res.json({ success: true, message: `Consent granted for ${purpose}` });
  } catch (error) {
    logger.error('Failed to grant consent', { error, userId, purpose });
    res.status(500).json({ success: false, error: 'Failed to grant consent' });
  }
});

/**
 * DELETE /auth/consents/:purpose - Withdraw consent for a purpose
 * Does not delete the record - sets withdrawn_at timestamp for audit
 */
app.delete('/auth/consents/:purpose', generalLimiter, authenticateJWT, async (req: Request, res: Response) => {
  const userId = req.user!.userId;
  const { purpose } = req.params;

  const validPurposes = ['location_discovery', 'marketing', 'analytics', 'after_hours'];
  if (!validPurposes.includes(purpose)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid purpose',
      validPurposes
    });
  }

  try {
    const result = await pool.query(
      `UPDATE user_consents
       SET granted = FALSE, withdrawn_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
       WHERE user_id = $1 AND purpose = $2
       RETURNING id`,
      [userId, purpose]
    );

    if (result.rowCount === 0) {
      // No consent existed - create a withdrawn record for audit trail
      await pool.query(
        `INSERT INTO user_consents (user_id, purpose, granted, withdrawn_at, consent_version)
         VALUES ($1, $2, FALSE, CURRENT_TIMESTAMP, $3)`,
        [userId, purpose, CURRENT_CONSENT_VERSION]
      );
    }

    logger.info('Consent withdrawn', { userId, purpose });
    res.json({ success: true, message: `Consent withdrawn for ${purpose}` });
  } catch (error) {
    logger.error('Failed to withdraw consent', { error, userId, purpose });
    res.status(500).json({ success: false, error: 'Failed to withdraw consent' });
  }
});
```

Add import for Request type if not already imported from express.
  </action>
  <verify>
Read backend/auth-service/src/index.ts and confirm:
1. GET /auth/consents endpoint exists
2. POST /auth/consents endpoint exists
3. DELETE /auth/consents/:purpose endpoint exists
4. All endpoints use authenticateJWT middleware
5. CURRENT_CONSENT_VERSION constant is defined
  </verify>
  <done>Auth-service has consent management endpoints (list, grant, withdraw)</done>
</task>

</tasks>

<verification>
1. Migration file exists at backend/migrations/026_add_user_consents.sql
2. Migration creates user_consents table with enum type
3. auth-service has GET /auth/consents endpoint
4. auth-service has POST /auth/consents endpoint
5. auth-service has DELETE /auth/consents/:purpose endpoint
6. `cd backend/auth-service && npm run build` compiles without errors
</verification>

<success_criteria>
- Migration 026 creates user_consents table
- Migration migrates existing after_hours_consent data
- GET /auth/consents returns all purposes with status
- POST /auth/consents grants consent with version tracking
- DELETE /auth/consents/:purpose withdraws consent (keeps audit trail)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-gdpr-compliance/02-03-SUMMARY.md`
</output>
